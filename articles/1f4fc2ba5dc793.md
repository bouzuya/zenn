---
emoji: "ğŸ‘Ÿ"
publication_name: "doctormate"
published: true
published_at: 2025-12-08 12:00
title: "axum crate ã®è¨­å®šã—ãŸ Router ã¯ã©ã†å‹•ãã®ã‹"
topics: ["rust"]
type: "tech"
---

# axum crate ã®è¨­å®šã—ãŸ Router ã¯ã©ã†å‹•ãã®ã‹

[å‰å›ã¯ axum crate ã‚’å­¦ã³ç›´ã—ã®ç¬¬ 2 å›ã§ Router ã® route ãƒ¡ã‚½ãƒƒãƒ‰ãªã©ã‚’è¦‹ã¾ã—ãŸ](https://zenn.dev/doctormate/articles/7ccac91c3773d5)ã€‚ ãªã‚“ã¨ãªãå†…éƒ¨æ§‹é€ ã‚’ã¤ã‹ã¿ã¯ã˜ã‚ãŸã¨ã“ã‚ã§ã™ã€‚

ä»Šå›ã¯ç¬¬ 3 å›ã§ `fallback` ã‚’è¦‹ã¦ã„ãã¨æ›¸ã„ãŸã®ã§ã™ãŒã€ã™ã“ã—èª­ã‚“ã§ã¿ã¦ã€å…ˆã«è¨­å®šã—ãŸ `Router` ãŒã©ã®ã‚ˆã†ã«å‹•ãã®ã‹ã‚’æŠŠæ¡ã™ã‚‹ã»ã†ãŒè‰¯ã„ã¨è€ƒãˆãŸã®ã§ã€ãã¡ã‚‰ã‚’ç¢ºèªã—ã¦ã„ãã¾ã™ã€‚

## serve ã‹ã‚‰ã¯ã˜ã‚ã‚‹

[å‰ã€…å›ã® axum crate ã®ã‹ã‚“ãŸã‚“ãªä¾‹](https://zenn.dev/doctormate/articles/37c97d448cc218) ã®ä¸­ã§ã€ `serve` ã®ä¾‹ãŒã‚ã‚Šã¾ã—ãŸã€‚å†æ²ã—ã¾ã™ã€‚

```rust
#[tokio::main]
async fn main() {
    let app = axum::Router::new()
        .route("/", axum::routing::get(root))
        .route("/users", axum::routing::post(create_user))
        .route("/users/{user_id}", axum::routing::get(get_user));
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

`Router` ã‚’ `serve` ã®ç¬¬äºŒå¼•æ•°ã«æŒ‡å®šã—ã€ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã¾ã—ãŸã€‚ã“ã“ã‚’ä»Šå›ã®å‡ºç™ºç‚¹ã«ã—ã¾ã™ã€‚

## serve ã®ã‚·ã‚°ãƒãƒãƒ£ã¨ make_service

<https://docs.rs/axum/0.8.4/axum/fn.serve.html>

```rust
pub fn serve<L, M, S>(listener: L, make_service: M) -> Serve<L, M, S>
where
    L: Listener,
    M: for<'a> Service<IncomingStream<'a, L>, Error = Infallible, Response = S>,
    S: Service<Request, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send,
```

`serve` ã¯æ€ã£ãŸã‚ˆã‚Šã‚‚è¤‡é›‘ãªã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

`Router` ã¯ç¬¬äºŒå¼•æ•°ã«æŒ‡å®šã§ããŸã®ã§ `M` ã®ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œ `for<'a> Service<IncomingStream<'a, L>, Error = Infallible, Response = S>` ã‚’æº€ãŸã—ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚

`Service` ã¯ `tower_service` crate ã® `Service` ã€‚ã¤ã¾ã‚Š `tower::Service` ã§ã™ã€‚

<https://docs.rs/tower-service/0.3.3/tower_service/trait.Service.html>

`IncomingStream` ã¯ `axum::serve::IncomingStream` ã§ã‚ã‚Šã€ `axum` crate ã§å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/serve/struct.IncomingStream.html>

`Infallible` ã¯ `std::convert::Infallible` ã§æ±ºã—ã¦å¤±æ•—ã—ãªã„ (èµ·ã“ã‚‰ãªã„) ã‚¨ãƒ©ãƒ¼ã®ã“ã¨ã§ã™ã­ã€‚

<https://doc.rust-lang.org/std/convert/enum.Infallible.html>

ã“ã“ã§ã® `S` ã¯ãŠãã‚‰ã HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ã‚µãƒ¼ãƒ“ã‚¹ã® S ã ã¨æ€ã„ã¾ã™ã€‚ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ»ã‚µãƒ¼ãƒ“ã‚¹ã«ã¤ã„ã¦ã¯ã„ãšã‚Œå‡ºã¦ãã‚‹ã¯ãšã§ã™ã€‚

ã‚„ã‚„ã“ã—ã„ã§ã™ãŒã€ã“ã“ã¾ã§ã§ `Router` ã¯ `Service` ã‚’è¿”ã™ `Service` ã«ãªã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

`Router` ã¯ `Service` ã§ `IncomingStream` ã‚’å—ã‘å–ã£ã¦ `Service` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã“ã§è¿”ã•ã‚ŒãŸ `Service` ã¯ `Request` ã‚’å—ã‘å–ã£ã¦ `Response` ã‚’è¿”ã™ `Service` ã¨ã„ã†ã“ã¨ã§ã™ã€‚

ã‚ã‚ã€ã‚„ã‚„ã“ã—ã„ã€‚

## impl Service<IncomingStream, ...> for Router<()>

ã•ã¦ã€å®Ÿè£…ã‚’æ¢ã—ã¾ã™ã€‚

`impl<L> Service<IncomingStream<'_, L>> for Router<()>` ã¯ `Router` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã® Trait Implementations ã‹ã‚‰è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#impl-Service%3CIncomingStream%3C'_,+L%3E%3E-for-Router>

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚‚è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ãŒã€ `Router<()>` ã®ã‚ˆã†ã« `Router<S>` ã® `S` ã¯ `()` ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã™ã¹ã¦ã® state ãŒæ¬ ã‘ã¦ã„ãªã„ `Router` ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã­ã€‚

å®Ÿè£…ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚

<https://docs.rs/axum/0.8.4/src/axum/routing/mod.rs.html#545-562>

```rust
impl<L> Service<serve::IncomingStream<'_, L>> for Router<()>
where
    L: serve::Listener,
{
    type Response = Self;
    type Error = Infallible;
    type Future = std::future::Ready<Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, _req: serve::IncomingStream<'_, L>) -> Self::Future {
        // call `Router::with_state` such that everything is turned into `Route` eagerly
        // rather than doing that per request
        std::future::ready(Ok(self.clone().with_state(())))
    }
}
```

`ready` ã‚„ã‚‰ã§ wrap ã•ã‚Œã¦ã„ã¾ã™ãŒã€ `self.clone().with_state(())` ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚

`with_state` ã¯ `Router` ã‚’è¿”ã—ã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.with_state>

ã¤ã¾ã‚Šã€ `Router` è‡ªèº«ãŒ `serve` ã® `S` ã‚’æº€ãŸã™ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

å†æ²: `serve` ã® `S` ã€‚

```rust
pub fn serve<L, M, S>(listener: L, make_service: M) -> Serve<L, M, S>
where
    L: Listener,
    M: for<'a> Service<IncomingStream<'a, L>, Error = Infallible, Response = S>,
    S: Service<Request, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send,
```

## impl Service<Request, ...> for Router

ã¾ãŸ `Service` ã®å®Ÿè£…ã‚’æ¢ã—ã¾ã™ã€‚ä»Šåº¦ã¯ `Request` ã‚’å—ã‘å–ã£ã¦ `Response` ã‚’è¿”ã™ `Service` ã® `Router` ã®ãŸã‚ã®å®Ÿè£…ã§ã™ã€‚

`impl<B> Service<Request<B>> for Router<()>` ã‚‚ `Router` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰ Trait Implementations ã‹ã‚‰è¦‹ã¤ã‘ã‚‰ã‚Œã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#impl-Service%3CRequest%3CB%3E%3E-for-Router>

å®Ÿè£…ã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/src/axum/routing/mod.rs.html#565-584>

```rust
impl<B> Service<Request<B>> for Router<()>
where
    B: HttpBody<Data = bytes::Bytes> + Send + 'static,
    B::Error: Into<axum_core::BoxError>,
{
    type Response = Response;
    type Error = Infallible;
    type Future = RouteFuture<Infallible>;

    #[inline]
    fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    #[inline]
    fn call(&mut self, req: Request<B>) -> Self::Future {
        let req = req.map(Body::new);
        self.call_with_state(req, ())
    }
}
```

`axum::body::Body::new` ã§ `http::Request<B>` ã‚’ map ã—ã€ `Router::call_with_state` ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

ã‚ˆã†ã‚„ãå‡¦ç†ã—ã¦ã„ã‚‹ç®‡æ‰€ã«ãŸã©ã‚Šã¤ããã†ã§ã™ã€‚

## Router::call_with_state

`call_with_state` ã¯å…¬é–‹ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã§ã¯ãªã„ã®ã§ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã¦ã‚‚åˆ†ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/mod.rs#L416-L431>

```rust
pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<Infallible> {
    let (req, state) = match self.inner.path_router.call_with_state(req, state) {
        Ok(future) => return future,
        Err((req, state)) => (req, state),
    };


    let (req, state) = match self.inner.fallback_router.call_with_state(req, state) {
        Ok(future) => return future,
        Err((req, state)) => (req, state),
    };


    self.inner
        .catch_all_fallback
        .clone()
        .call_with_state(req, state)
}
```

æ¥ã¾ã—ãŸã­ã€‚

`self.inner.path_router.call_with_state` ã‚’å‘¼ã³å‡ºã—ã€æˆåŠŸã™ã‚Œã°è¿”ã—ã¦çµ‚äº†ã€å¤±æ•—ã™ã‚Œã°æ¬¡ã¸ã€‚

`self.inner.fallback_router.call_with_state` ã‚’å‘¼ã³å‡ºã—ã€æˆåŠŸã™ã‚Œã°è¿”ã—ã¦çµ‚äº†ã€å¤±æ•—ã™ã‚Œã°æ¬¡ã¸ã€‚

`self.inner.catch_all_fallback.call_with_state` ã‚’å‘¼ã³å‡ºã™ã€‚

[å‰å›ã¯åˆ†ã‹ã‚‰ãªã‹ã£ãŸ `RouterInner` ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰](https://zenn.dev/doctormate/articles/7ccac91c3773d5) ãŒãªã‚“ã¨ãªãè¦‹ãˆã€å½“åˆä»Šå›ã®ã‚´ãƒ¼ãƒ«ã«è¨­å®šã—ã¦ã„ãŸ `fallback` ã‚‚è¿‘ã¥ã„ã¦ãã¾ã—ãŸã­ã€‚

## PathRouter::call_with_state

ä»Šå›ã¯ `PathRouter` ã‚’è¦‹ã¦çµ‚ã‚ã‚Šã«ã—ã¾ã—ã‚‡ã†ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L371-L420>

```rust
pub(super) fn call_with_state(
    &self,
    #[cfg_attr(not(feature = "original-uri"), allow(unused_mut))] mut req: Request,
    state: S,
) -> Result<RouteFuture<Infallible>, (Request, S)> {
    #[cfg(feature = "original-uri")]
    {
        use crate::extract::OriginalUri;


        if req.extensions().get::<OriginalUri>().is_none() {
            let original_uri = OriginalUri(req.uri().clone());
            req.extensions_mut().insert(original_uri);
        }
    }


    let (mut parts, body) = req.into_parts();


    match self.node.at(parts.uri.path()) {
        Ok(match_) => {
            let id = *match_.value;


            if !IS_FALLBACK {
                #[cfg(feature = "matched-path")]
                crate::extract::matched_path::set_matched_path_for_request(
                    id,
                    &self.node.route_id_to_path,
                    &mut parts.extensions,
                );
            }


            url_params::insert_url_params(&mut parts.extensions, match_.params);


            let endpoint = self
                .routes
                .get(&id)
                .expect("no route for id. This is a bug in axum. Please file an issue");


            let req = Request::from_parts(parts, body);
            match endpoint {
                Endpoint::MethodRouter(method_router) => {
                    Ok(method_router.call_with_state(req, state))
                }
                Endpoint::Route(route) => Ok(route.clone().call_owned(req)),
            }
        }
        // explicitly handle all variants in case matchit adds
        // new ones we need to handle differently
        Err(MatchError::NotFound) => Err((Request::from_parts(parts, body), state)),
    }
}
```

ä»Šå›ã®å¼•ç”¨ã§ã¯æœ€é•·ã§ã™ã­ã€‚

ã–ã£ãã‚Šã¨è¦‹ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

1. `req.into_parts()` ã§ HTTP ãƒœãƒ‡ã‚£ã¨ãã‚Œä»¥å¤–ã«åˆ†ã‘ã¦
2. `self.node.at(parts.uri.path())` ã§ãƒãƒƒãƒã™ã‚‹ãƒ«ãƒ¼ãƒˆ (ã®ID) ã‚’æ¢ã—ã¦
3. ã‚ã‚Œã° `self.routes.get(&id)` ã§ `Endpoint` ã‚’å¾—ã¦ã€ãªã‘ã‚Œã° Err
4. `Endpoint` ãŒ `MethodRouter` ãªã‚‰ `call_with_state` ã€ãƒã‚¹ãƒˆã—ãŸ `Route` ãªã‚‰ `call_owned` ã§ã•ã‚‰ã«å‘¼ã³å‡ºã—

## Node::at 

`self.node.at` (`Node::at`) ã‚’è¦‹ã‚‹ã¨ã€ `self.inner.at` ã«ä¸¸æŠ•ã’ã•ã‚Œã¦ã„ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/main/axum/src/routing/path_router.rs#L453-L458>

```rust
fn at<'n, 'p>(
    &'n self,
    path: &'p str,
) -> Result<matchit::Match<'n, 'p, &'n RouteId>, MatchError> {
    self.inner.at(path)
}
```

`Node::inner` ã¯ `matchit` crate ã® `Router` ã§ã™ã€‚

<https://github.com/tokio-rs/axum/blob/main/axum/src/routing/path_router.rs#L430-L434>

```rust
struct Node {
    inner: matchit::Router<RouteId>,
    route_id_to_path: HashMap<RouteId, Arc<str>>,
    path_to_route_id: HashMap<Arc<str>, RouteId>,
}
```

[matchit](https://crates.io/crates/matchit) ã¯ axum crate ã¨ã¯åˆ¥ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã§ã™ã€‚

ã“ã¡ã‚‰ã®è©³ç´°ã¯åˆ¥ã®æ©Ÿä¼šã«èª­ã‚€ã“ã¨ã«ã—ã¾ã™ã€‚

## æ®‹ã‚Šã®å‡¦ç†

`PathRouter::call_with_state` ã«æˆ»ã‚Šã€ `Node::at` ã§ãƒãƒƒãƒã—ãŸãƒ«ãƒ¼ãƒˆã® `value` (`RouteId`) ã¨ `params` ã‚’å¾—ãŸã¨ã“ã‚ã‹ã‚‰è¦‹ã¾ã™ã€‚

å¾—ã‚‰ã‚ŒãŸ `id: RouteId` ã§ `Router::routes` ã‹ã‚‰ `Endpoint` ã‚’å¾—ã¾ã™ã€‚ `self.routes.get(&id)` ã§ã™ã­ã€‚

`Endpoint` ã® variant ã§åˆ†å²ã—ã¦ã€ `MethodRouter::call_with_state` ã¨ `Route::call_owned` ã‚’å‘¼ã³åˆ†ã‘ã¾ã™ã€‚

ãã—ã¦â€¦â€¦ `MethodRouter` ä»¥é™ã¯â€¦â€¦çœç•¥ï¼ã€€åŠ›å°½ãã¾ã—ãŸï¼

ã“ã®ã‚ã¨ã¯ `Route::oneshot_inner_owned` ã‚’å‘¼ã³å‡ºã—ã¦ã€ `tower::util::BoxCloneSyncService::oneshot` ã®å‘¼ã³å‡ºã—ã¸ã¨ã¤ãªãŒã£ã¦ã„ãã‚ˆã†ã§ã™ã€‚ã“ã“ã¯ã¾ãŸãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã¾ãŸå‡ºã¦ãã‚‹ã¨æ€ã„ã¾ã™ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ `axum` crate ã®å­¦ã³ç›´ã—ã®ç¬¬ 3 å›ã¨ã—ã¦ã€è¨­å®šã—ãŸ `Router` ãŒã©ã†å‹•ãã®ã‹ã‚’è¿½ã„ã‹ã‘ã¦ã¿ã¾ã—ãŸã€‚
