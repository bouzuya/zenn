---
emoji: "🐙"
publication_name: "doctormate"
published: true
published_at: 2026-03-16 12:00
title: "axum crate の Middleware (3) axum::middleware::from_extractor"
topics: ["rust"]
type: "tech"
---

[前回は axum の middleware のドキュメントの Writing middleware から axum::middleware::from_fn について見ました](https://zenn.dev/doctormate/articles/2582963afb4646)。

今回は axum の middleware のドキュメントから `axum::middleware::from_extractor` 以降を読んでいきます。

今回も axum crate のバージョンは 0.8.4 です。

## axum::middleware::from_extractor のドキュメント

まずはドキュメントを見ます。前回は `axum::middleware::from_fn` のところまでだったので、その続きからです。

<https://docs.rs/axum/0.8.4/axum/middleware/index.html>

[`axum::middleware::from_extractor`](https://docs.rs/axum/0.8.4/axum/middleware/fn.from_extractor.html)

これは Extractor から Middleware を作成するものです。成功すれば抽出された値は捨てられて後続の Service が呼び出され、失敗すれば後続の Service は呼び出されない。また `FromRequest` (Request Bodyを消費するもの) の場合、後続の Service では Request Body が読めない……とのことです。

つまり、 Extractor だけど実際に値を抽出して使うのではなく値を抽出できるかの判定を使うということみたいですね。

例にもあるとおり、ヘッダーから認証用の情報を抽出するみたいな Extractor を、各 Handler に都度入れると冗長になるから Middleware として一括設定してあげれば……というのがユースケースとして分かりやすそうですね。

## axum::middleware::from_extractor の実装

`axum::middleware::from_extractor` の実装は……

```rust
pub fn from_extractor<E>() -> FromExtractorLayer<E, ()> {
    from_extractor_with_state(())
}
```

`from_extractor_with_state` に丸投げですね。これは前回の `axum::middleware::from_fn` とほとんど同じ形です。

<https://docs.rs/axum/0.8.4/axum/middleware/fn.from_extractor_with_state.html>

```rust
pub fn from_extractor_with_state<E, S>(state: S) -> FromExtractorLayer<E, S> {
    FromExtractorLayer {
        state,
        _marker: PhantomData,
    }
}
```

`FromExtractorLayer` を返します。既視感があります。

```rust
impl<E, T, S> Layer<T> for FromExtractorLayer<E, S>
where
    S: Clone,
{
    type Service = FromExtractor<T, E, S>;

    fn layer(&self, inner: T) -> Self::Service {
        FromExtractor {
            inner,
            state: self.state.clone(),
            _extractor: PhantomData,
        }
    }
}
```

`FromExtractor` を返します。既視感があります。

```rust
impl<T, E, B, S> Service<Request<B>> for FromExtractor<T, E, S>
where
    E: FromRequestParts<S> + 'static,
    B: Send + 'static,
    T: Service<Request<B>> + Clone,
    T::Response: IntoResponse,
    S: Clone + Send + Sync + 'static,
{
    type Response = Response;
    type Error = T::Error;
    type Future = ResponseFuture<B, T, E, S>;

    #[inline]
    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let state = self.state.clone();
        let (mut parts, body) = req.into_parts();

        let extract_future = Box::pin(async move {
            let extracted = E::from_request_parts(&mut parts, &state).await;
            let req = Request::from_parts(parts, body);
            (req, extracted)
        });

        ResponseFuture {
            state: State::Extracting {
                future: extract_future,
            },
            svc: Some(self.inner.clone()),
        }
    }
}
```

Extractor 自体が `FromRequestParts` や `FromRequest` を実装しているので、前回の `from_fn` とは異なり `impl Service for FromExtractor` はマクロで可変に対応する形では定義されていません。

`from_request_parts` を呼び出すだけではありますね。

`ResponseFuture` は `impl Future for ResponseFuture` が実装されています。説明通り Extractor が成功すれば inner service を呼び出し、失敗すればエラーを into_response して返すものです。

```rust
pin_project! {
    /// Response future for [`FromExtractor`].
    #[allow(missing_debug_implementations)]
    pub struct ResponseFuture<B, T, E, S>
    where
        E: FromRequestParts<S>,
        T: Service<Request<B>>,
    {
        #[pin]
        state: State<B, T, E, S>,
        svc: Option<T>,
    }
}

pin_project! {
    #[project = StateProj]
    enum State<B, T, E, S>
    where
        E: FromRequestParts<S>,
        T: Service<Request<B>>,
    {
        Extracting {
            future: BoxFuture<'static, (Request<B>, Result<E, E::Rejection>)>,
        },
        Call { #[pin] future: T::Future },
    }
}

impl<B, T, E, S> Future for ResponseFuture<B, T, E, S>
where
    E: FromRequestParts<S>,
    T: Service<Request<B>>,
    T::Response: IntoResponse,
{
    type Output = Result<Response, T::Error>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            let mut this = self.as_mut().project();

            let new_state = match this.state.as_mut().project() {
                StateProj::Extracting { future } => {
                    let (req, extracted) = ready!(future.as_mut().poll(cx));

                    match extracted {
                        Ok(_) => {
                            let mut svc = this.svc.take().expect("future polled after completion");
                            let future = svc.call(req);
                            State::Call { future }
                        }
                        Err(err) => {
                            let res = err.into_response();
                            return Poll::Ready(Ok(res));
                        }
                    }
                }
                StateProj::Call { future } => {
                    return future
                        .poll(cx)
                        .map(|result| result.map(IntoResponse::into_response));
                }
            };

            this.state.set(new_state);
        }
    }
}
```

`pin-project-lite` crate の `pin_project` マクロについては別の機会に書きます。

## おわりに

今回は axum の middleware の `axum::middleware::from_extractor` を見ました。

すこしずつしか進められていません……。

次回も引き続き、他の Middleware を書く方法も見ていこうと思います。
