---
emoji: "ğŸ“›"
publication_name: "doctormate"
published: false
# published_at: 2025-09-11 12:00
title: "derive macro ã® helper attribute ã‚’è©¦ã™"
topics: ["rust"]
type: "tech"
---

# derive macro ã® helper attribute ã‚’è©¦ã™

[å‰å›ã¯ derive macro ã‚’æ›¸ã„ã¦ã¿ã¾ã—ãŸ][zenn:0a7cc9365d90cd] ã€‚ä»Šå›ã¯å‰å›ã® derive macro ã®ä¾‹ã« helper attribute ã‚’è¿½åŠ ã—ã¾ã™ã€‚

## å‰å›ã® derive macro ã®ä¾‹

å‰å›ã¯ã€ã“ã‚ŒãŒ

```rust
#[derive(derive1::VariantsFn)]
enum E1 {
    A,
    B(i32),
    C { b: bool },
}
```

ã“ã†ãªã‚‹

```rust
enum E1 {
    A,
    B(i32),
    C { b: bool },
}
impl E1 {
    pub fn variants() -> &'static [&'static str] {
        &["A", "B", "C"]
    }
}
```

`VariantsFn` ã¨ã„ã† derive macro ã‚’å®šç¾©ã—ã¾ã—ãŸã€‚

## ä»Šå›ã¯ `rename` å±æ€§ã‚’è¿½åŠ ã™ã‚‹

ä»Šå›ã¯ã“ã“ã« `rename` ã¨ã„ã† derive macro helper attribute ã‚’è¿½åŠ ã—ã¾ã™ã€‚`rename` å±æ€§ãŒæŒ‡å®šã•ã‚ŒãŸ variant ã¯è­˜åˆ¥å­ã®æ–‡å­—åˆ—è¡¨ç¾ã®ä»£ã‚ã‚Šã« `rename` ã§æŒ‡å®šã•ã‚ŒãŸæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

æ¬¡ã®ã‚ˆã†ãªã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

```rust
#[derive(derive1::VariantsFn)]
enum E1 {
    #[rename = "X"]
    A,
    B(i32),
    C { b: bool },
}

fn main() {
    // "A" ã§ã¯ãªã "X" ãŒä½¿ç”¨ã•ã‚Œã‚‹
    assert_eq!(E1::variants(), &["X", "B", "C"]);
}
```

## define macro helper attributes ã®å®šç¾©

`proc_macro_derive` å±æ€§ã«ã¯ `attributes` ã‚­ãƒ¼ã§ derive macro helper attributes ã‚’æŒ‡å®šã§ãã¾ã™ã€‚

å…¬å¼ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã«ã‚ã‚‹ä¾‹ã§ã™ã€‚

<https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes>

```rust
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -> TokenStream {
    TokenStream::new()
}
```

```rust
#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}
```

## å‰å›ã®ä¾‹ã¸ã®è¿½åŠ 

å‰å›ã‹ã‚‰å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¤ºã—ã¾ã™ã€‚ä»Šå›ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®è‚å¿ƒãªéƒ¨åˆ†ã¯ `#[proc_macro_deri(..., attributes(helper))]` ã®ç®‡æ‰€ã§ã™ã€‚

`crates/derive1/src/lib.rs`

```rust
use proc_macro::TokenStream;
use syn::spanned::Spanned;

#[proc_macro_derive(VariantsFn, attributes(rename))]
pub fn derive_variants_fn(input: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(input as syn::DeriveInput);

    let data_enum = if let syn::Data::Enum(data_enum) = &input.data {
        data_enum
    } else {
        return TokenStream::from(
            syn::Error::new(input.span(), "VariantsFn can only be derived for enums")
                .to_compile_error(),
        );
    };

    let enum_ident = input.ident;
    let enum_variant_names = match data_enum
        .variants
        .iter()
        .map(|variant| {
            match variant
                .attrs
                .iter()
                .find(|attr| attr.path().is_ident("rename"))
            {
                None => Ok(variant.ident.to_string()),
                Some(attr) => {
                    let meta_name_value = attr.meta.require_name_value().map_err(|_| {
                        syn::Error::new(attr.span(), "expected `#[rename = \"name\"]` attribute")
                    })?;
                    match &meta_name_value.value {
                        syn::Expr::Lit(syn::ExprLit {
                            lit: syn::Lit::Str(lit_str),
                            ..
                        }) => Ok(lit_str.value()),
                        _ => Err(syn::Error::new(
                            meta_name_value.span(),
                            "expected string literal for rename value",
                        )),
                    }
                }
            }
        })
        .collect::<syn::Result<Vec<String>>>()
    {
        Ok(enum_variant_names) => enum_variant_names,
        Err(e) => return TokenStream::from(e.to_compile_error()),
    };
    let output = quote::quote! {
        impl #enum_ident {
            pub fn variants() -> &'static [&'static str] {
                &[#(#enum_variant_names,)*]
            }
        }
    };

    TokenStream::from(output)
}
```

ã¾ãšã¯è‚å¿ƒãªéƒ¨åˆ†ã€‚ `#[proc_macro_derive(VariantsFn, attributes(rename))]` ã€‚ `VariantsFn` ã¨ã„ã† derive macro ã® helper attribute ã¨ã—ã¦ `rename` ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ç¹°ã‚Šè¿”ã—ã¾ã™ãŒã€ã“ã® 1 è¡ŒãŒã“ã®è¨˜äº‹ã®ãƒ¡ã‚¤ãƒ³ã§ã™ã€‚

ã‚ã¨ã¯ `#[rename = "..."]` ã¨æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«å‡¦ç†ã‚’å¤‰æ›´ã—ã¦ã„ã¾ã™ã€‚ variant ã”ã¨ã«å±æ€§ã‚’èª¿ã¹ã€ãã® path ãŒ `rename` ã®ã‚‚ã®ã«ã¤ã„ã¦ NameValue (`name = value`) ã§ expr ãŒ Lit ã® Str `"..."` ã§ã‚ã‚Œã°ãã‚Œã‚’ä½¿ã„ã€ãã†ã§ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚

ã“ã®ã‚ãŸã‚Šã¯ã‚„ã‚ŠãŸã„ã“ã¨ã«ã‚ˆã£ã¦å¤‰ã‚ã‚‹ã®ã§ã€éƒ½åº¦èª¿ã¹ã‚Œã°ã„ã„ã®ã‹ãªã¨æ€ã„ã¾ã™ã€‚ã¼ãã¯ `syn` crate ãŒæä¾›ã™ã‚‹æ§‹é€ ä½“ã‚’èª¿ã¹ãªãŒã‚‰é©å½“ã«å…¥ã‚Œã¾ã—ãŸã€‚

å€‹äººçš„ã«ã¯è¡çªãŒæ°—ã«ãªã‚‹ã®ã§ `#[variants_fn(rename = "...")]` ã¿ãŸã„ãªå½¢å¼ã«ã—ã‚ˆã†ã‹ã¨æ€ã£ãŸã®ã§ã™ãŒã€ä¾‹ã¨ã—ã¦ã¯ã”ã¡ã‚ƒã¤ãã®ã§ãƒœãƒ„ã«ã—ã¾ã—ãŸã€‚

ã¨ã“ã‚ã§ã€ `proc_macro_derive` ã® helper attribute ã¨ã—ã¦ `rename` ã‚’è¿½åŠ ã—ãªã„ã¨ã©ã†ãªã‚‹ã®ã‹ã€‚ã‚‚ã—è¿½åŠ ã—ã¦ã„ãªã„ã¨æ¬¡ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

```
error: cannot find attribute `rename` in this scope
```

å±æ€§ãŒä»–ã® macro ãªã©ã«ã‚ˆã£ã¦å°å…¥ã•ã‚Œã¦ã„ãªã„å ´åˆã“ã†ã„ã†ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ derive macro helper attributes ã«ã¤ã„ã¦æ›¸ãã¾ã—ãŸã€‚å‰å›ã®ãŠã¾ã‘ã¿ãŸã„ãªå†…å®¹ã§ã—ãŸã€‚

æ¬¡å›ã¯æ”¹ã‚ã¦ `trybuild` crate ã«ã¤ã„ã¦æ›¸ãã¾ã™ã€‚

## å‚è€ƒ

- Procedural Macros - The Rust Reference <https://doc.rust-lang.org/reference/procedural-macros.html>
- Derive - The Rust Reference <https://doc.rust-lang.org/reference/attributes/derive.html>
- syn - crates.io: Rust Package Registry <https://crates.io/crates/syn>


[zenn:0a7cc9365d90cd]: https://zenn.dev/doctormate/articles/0a7cc9365d90cd
