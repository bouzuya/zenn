---
emoji: "🦁"
publication_name: "doctormate"
published: true
published_at: 2026-04-20 12:00
title: "non_exhaustive でフィールド・バリアント追加で壊れないコードを強制しよう"
topics: ["rust"]
type: "tech"
---

[以前の記事](https://zenn.dev/doctormate/articles/e0e241712f5cad)ではフィールドを追加したときコンパイルエラーになるような詰め替え時のパターンを提案しました。

今回は逆に、フィールドを追加したときコンパイルエラーにならないようにするための属性 `#[non_exhaustive]` を紹介します。

## non_exhaustive 属性とは

exhaustive は「網羅的な」などの意味を持ちます。 non_exhaustive はそれを否定したものなので「網羅的ではない」ということです。

non_exhaustive 属性は enum, enum のバリアント, struct のフィールドなどに設定し、将来的にフィールドやバリアントが追加される可能性がある (網羅的ではない) ことを示す属性です。

<https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute>

おそらく、この説明では、いまひとつピンと来ないと思います。「網羅的でない・追加される可能性があることを示す」と言われても、「そりゃ追加される可能性はあるだろう」となりませんか、ぼくはなりました。

もうすこし説明するなら「網羅的でない・追加される可能性を示し、それを考慮していない (追加されたときにコンパイルエラーになる) 記述をコンパイルエラーにする」ための属性です。さらに「？」が浮かんでいそうなので例で説明します。

## 追加を考慮していない (追加されたときにコンパイルエラーになる) 記述

まずは属性の効果を感じるために、あえて「追加を考慮していない (追加されたときにコンパイルエラーになる) 記述」が何かを考えます。

### 例1

これは[以前の記事](https://zenn.dev/doctormate/articles/e0e241712f5cad)の例が該当します。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(CreateUserOutput { email, id, name }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

引数部分でパターンマッチによって destructuring しています。ここはフィールドが追加されるとコンパイルエラーになります。

ここをフィールドが追加されたときコンパイルエラーにならないようにするにはどうすれば良いでしょう？

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(CreateUserOutput { email, id, name, .. }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

そうです `..` を追加すれば良いです。これでフィールドが追加されても、コンパイルエラーになりません。


### 例2

先の例の `CreateUserOutput` を構築する場面を考えてみましょう。

```rust
let _ = CreateUserOutput {
    email: "e".to_owned(),
    id: "i".to_owned(),
    name: "n".to_owned(),
};
```

ここもフィールドが追加されるとコンパイルエラーになります。

フィールドを指定しての構築はできません。 `CreateUserOutput::new(...)` のようなメソッドを追加してもらい、それを呼び出すことなどで回避できるでしょう。

### 例3

今度は新しい例として enum を考えます。

```rust
enum Fruit {
    Apple,
    Banana,
}

let fruit = Fruit::Apple;

match fruit {
    Fruit::Apple => println!("apple"),
    Fruit::Banana => println!("banana"),
}
```

この `match` はバリアントが追加されるとコンパイルエラーになります。

回避するにはどうすれば良いでしょうか？

```rust
match fruit {
    Fruit::Apple => println!("apple"),
    Fruit::Banana => println!("banana"),
    #[allow(unreachable_patterns)]
    _ => println!("?"),
}
```

そうです `_ => ...` を追加すれば良いです。 (ここは `#[non_exhaustive]` が指定されていない状況では `unreachable_patterns` という警告が表示されてしまうので、ここでは警告を許可しています)

このようにフィールドやバリアントの追加をコンパイルエラーにしないように備える記述は用意されています。

## non_exhaustive 属性の役割

改めて、先の `#[non_exhaustive]` の説明を示します。

「網羅的でない・追加される可能性を示し、それを考慮していない (追加されたときにコンパイルエラーになる) 記述をコンパイルエラーにする」ための属性です。

ここまでの例で示したとおり `#[non_exhaustive]` は

- `..` を伴わないパターンマッチをコンパイルエラーにする
- フィールドを指定して構築するのをコンパイルエラーにする
- `_ => ...` を伴わないパターンマッチをコンパイルエラーにする

などの、フィールドやバリアントが追加される可能性を考慮していない記述をコンパイルエラーにする属性です。

## 注意

注意事項があります。この属性は型が定義されている crate 内では効果がありません。同じコンパイル単位なら、一緒に変更すればいいだけだからでしょう。

他の crate から、その型を参照したときにはじめて効果が出ます。

これは、ある crate の変更によってそれに依存する他の crate に壊れるような記述をさせないための属性だからでしょう。

## おわりに

以前は追加時にあえてコンパイルエラーにするためのパターンを、今回は追加時にコンパイルエラーにしないための属性を紹介しました。

コンパイルエラーは多くの場合に良いものです。一方で、場合によっては追加によってコンパイルエラーが出ないよう、互換性を維持しながら追加したいこともあります。

うまく意図を表現したコードを書いていきたいですね。

## 参考

- The non_exhaustive attribute - Type System - The Rust Reference <https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute>
- ぼくの書いたその他のコード例 <https://github.com/bouzuya/rust-examples/tree/f3f205895d801bb7345d5f995de934410943e260/non_exhaustive>
