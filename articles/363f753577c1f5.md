---
emoji: "🦔"
publication_name: "doctormate"
published: true
published_at: 2026-03-02 12:00
title: "axum crate の middleware"
topics: ["rust"]
type: "tech"
---

[前回は axum crate の エラーハンドリングを見ました](https://zenn.dev/doctormate/articles/0ae1263c351356)。

今回は axum の middleware のドキュメント (の前半) を見ていきます。

今回も axum crate のバージョンは 0.8.4 です。

## axum の middleware

まずはドキュメントを見ていきます。

<https://docs.rs/axum/0.8.4/axum/middleware/index.html>

[第一回の axum の概要](https://zenn.dev/doctormate/articles/37c97d448cc218) でも触れたのですが、 axum は middleware を独自には持たず、代わりに `tower` を使っていることが書かれています。

また `tower` crate のガイドを読むようにすすめられています。完全な理解はせずとも基本的なところは理解すべきとのことです。ミーム的に「完全に理解した」はあまり完全ではなさそうですが……。

<https://github.com/tower-rs/tower/tree/master/guides>

これは読み出すと終わらないので別の機会に。

あとは `tower::ServiceBuilder` のドキュメントを読むこともすすめられています。

<https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html>

## Middleware の適用箇所

次は Middleware の適用箇所について書いてあります。

- Router 単位での適用 (`Router::layer` と `Router::route_layer`)
- MethodRouter 単位での適用 (`MethodRouter::layer` と `MethodRouter::route_layer`)
- Handler 単位での適用 (`Handler::layer`)

このあたりは Router や Handler の回にもすこし見ていますね。

## 複数 Middleware の適用と順序

複数の Middleware の適用は `tower::ServiceBuilder` を使うことをすすめられています。

複数の Middleware の適用では、その順序が重要になります。

`Router::layer` は下から上 (内側から外側) の順。これは後から足したもので wrap することによります。

```rust
use axum::{routing::get, Router};

async fn handler() {}

let app = Router::new()
    .route("/", get(handler))
    .layer(layer_one)
    .layer(layer_two)
    .layer(layer_three);
```

ドキュメントにある図は分かりやすいですね。

```text
        requests
           |
           v
+----- layer_three -----+
| +---- layer_two ----+ |
| | +-- layer_one --+ | |
| | |               | | |
| | |    handler    | | |
| | |               | | |
| | +-- layer_one --+ | |
| +---- layer_two ----+ |
+----- layer_three -----+
           |
           v
        responses
```

`tower::ServiceBuilder` は逆の上から下 (内側から外側) の順。これは紛らわしいですね……。より直感的な順序になるのもこちらを推奨する理由のひとつとのこと。

```rust
use tower::ServiceBuilder;
use axum::{routing::get, Router};

async fn handler() {}

let app = Router::new()
    .route("/", get(handler))
    .layer(
        ServiceBuilder::new()
            .layer(layer_one)
            .layer(layer_two)
            .layer(layer_three),
    );
```

```text
        requests
           |
           v
+------ layer_one ------+
| +---- layer_two ----+ |
| | +- layer_three -+ | |
| | |               | | |
| | |    handler    | | |
| | |               | | |
| | +- layer_three -+ | |
| +---- layer_two ----+ |
+------ layer_one ------+
           |
           v
        responses
```

## Router::layer の実装

実装を見ていきましょう。

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.layer>

```rust
pub fn layer<L>(self, layer: L) -> Router<S>
where
    L: Layer<Route> + Clone + Send + Sync + 'static,
    L::Service: Service<Request> + Clone + Send + Sync + 'static,
    <L::Service as Service<Request>>::Response: IntoResponse + 'static,
    <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
    <L::Service as Service<Request>>::Future: Send + 'static,
{
    map_inner!(self, this => RouterInner {
        path_router: this.path_router.layer(layer.clone()),
        fallback_router: this.fallback_router.layer(layer.clone()),
        default_fallback: this.default_fallback,
        catch_all_fallback: this.catch_all_fallback.map(|route| route.layer(layer)),
    })
}
```

```rust
macro_rules! map_inner {
    ( $self_:ident, $inner:pat_param => $expr:expr) => {
        #[allow(redundant_semicolons)]
        {
            let $inner = $self_.into_inner();
            Router {
                inner: Arc::new($expr),
            }
        }
    };
}
```

`PathRouter::layer` を呼び出した `RouterInner` で `Router` を構築します。

`PathRouter::layer` の実装は……

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L285-L308>

```rust
pub(super) fn layer<L>(self, layer: L) -> PathRouter<S, IS_FALLBACK>
where
    L: Layer<Route> + Clone + Send + Sync + 'static,
    L::Service: Service<Request> + Clone + Send + Sync + 'static,
    <L::Service as Service<Request>>::Response: IntoResponse + 'static,
    <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
    <L::Service as Service<Request>>::Future: Send + 'static,
{
    let routes = self
        .routes
        .into_iter()
        .map(|(id, endpoint)| {
            let route = endpoint.layer(layer.clone());
            (id, route)
        })
        .collect();


    PathRouter {
        routes,
        node: self.node,
        prev_route_id: self.prev_route_id,
        v7_checks: self.v7_checks,
    }
}
```

各 `Endpoint::layer` を呼び出した `routes` で `PathRouter` を構築します。

`Endpoint::layer` の実装は……

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/mod.rs#L757-L772>

```rust
fn layer<L>(self, layer: L) -> Endpoint<S>
where
    L: Layer<Route> + Clone + Send + Sync + 'static,
    L::Service: Service<Request> + Clone + Send + Sync + 'static,
    <L::Service as Service<Request>>::Response: IntoResponse + 'static,
    <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
    <L::Service as Service<Request>>::Future: Send + 'static,
{
    match self {
        Endpoint::MethodRouter(method_router) => {
            Endpoint::MethodRouter(method_router.layer(layer))
        }
        Endpoint::Route(route) => Endpoint::Route(route.layer(layer)),
    }
}
```

`MethodRouter::layer` を呼び出しています。

`MethodRouter::layer` の実装は……

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/method_routing.rs#L965-L991>

```rust
pub fn layer<L, NewError>(self, layer: L) -> MethodRouter<S, NewError>
where
    L: Layer<Route<E>> + Clone + Send + Sync + 'static,
    L::Service: Service<Request> + Clone + Send + Sync + 'static,
    <L::Service as Service<Request>>::Response: IntoResponse + 'static,
    <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
    <L::Service as Service<Request>>::Future: Send + 'static,
    E: 'static,
    S: 'static,
    NewError: 'static,
{
    let layer_fn = move |route: Route<E>| route.layer(layer.clone());


    MethodRouter {
        get: self.get.map(layer_fn.clone()),
        head: self.head.map(layer_fn.clone()),
        delete: self.delete.map(layer_fn.clone()),
        options: self.options.map(layer_fn.clone()),
        patch: self.patch.map(layer_fn.clone()),
        post: self.post.map(layer_fn.clone()),
        put: self.put.map(layer_fn.clone()),
        trace: self.trace.map(layer_fn.clone()),
        connect: self.connect.map(layer_fn.clone()),
        fallback: self.fallback.map(layer_fn),
        allow_header: self.allow_header,
    }
}
```

`Route::layer` を呼び出すクロージャで `MethodEndpoint::map` を呼び出しています。

`MethodEndpoint::map` の実装は……。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/method_routing.rs#L1241-L1253>

```rust
fn map<F, E2>(self, f: F) -> MethodEndpoint<S, E2>
where
    S: 'static,
    E: 'static,
    F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + Sync + 'static,
    E2: 'static,
{
    match self {
        Self::None => MethodEndpoint::None,
        Self::Route(route) => MethodEndpoint::Route(f(route)),
        Self::BoxedHandler(handler) => MethodEndpoint::BoxedHandler(handler.map(f)),
    }
}
```

`Route::layer` の実装は……。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/route.rs#L60-L73>

```rust
pub(crate) fn layer<L, NewError>(self, layer: L) -> Route<NewError>
where
    L: Layer<Route<E>> + Clone + Send + 'static,
    L::Service: Service<Request> + Clone + Send + Sync + 'static,
    <L::Service as Service<Request>>::Response: IntoResponse + 'static,
    <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
    <L::Service as Service<Request>>::Future: Send + 'static,
    NewError: 'static,
{
    let layer = (MapErrLayer::new(Into::into), layer);


    Route::new(layer.layer(self))
}
```

ここでようやく引数が外側になる wrap っぽい動きになっていそうです。

念のための `Tower::layer` の実装は……

<https://github.com/tower-rs/tower/blob/tower-0.5.2/tower-layer/src/lib.rs#L95-L112>

```rust
pub trait Layer<S> {
    /// The wrapped service
    type Service;
    /// Wrap the given service with the middleware, returning a new service
    /// that has been decorated with the middleware.
    fn layer(&self, inner: S) -> Self::Service;
}
```

追いかけるのが大変そうなのでここで打ち切りますが、変数名からして引数側が inner でしょう。

全体としては「引数を外側に」となる形ですね。

## ServiceBuilder::layer の実装

次は `ServiceBuilder::layer` の実装を見てみます。

<https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html>

```rust
pub struct ServiceBuilder<L> {
    layer: L,
}
```

```rust
pub fn layer<T>(self, layer: T) -> ServiceBuilder<Stack<T, L>> {
    ServiceBuilder {
        layer: Stack::new(layer, self.layer),
    }
}
```

`Stack::new` の第一引数に引数で受け取った layer 、第二引数に自身の layer を渡して呼び出しています。

`Stack::new` と `Stack::layer` の実装は……

<https://github.com/tower-rs/tower/blob/tower-0.5.2/tower-layer/src/stack.rs#L11-L30>

```rust
impl<Inner, Outer> Stack<Inner, Outer> {
    /// Create a new `Stack`.
    pub const fn new(inner: Inner, outer: Outer) -> Self {
        Stack { inner, outer }
    }
}


impl<S, Inner, Outer> Layer<S> for Stack<Inner, Outer>
where
    Inner: Layer<S>,
    Outer: Layer<Inner::Service>,
{
    type Service = Outer::Service;


    fn layer(&self, service: S) -> Self::Service {
        let inner = self.inner.layer(service);


        self.outer.layer(inner)
    }
}
```

`Stack::new` は `inner` → `outer` を受け取りますね。

全体では「引数を内側に」となる形ですね。


## Middleware の作成 (WIP)

- `axum::middleware::from_fn`
- `axum::middleware::from_extractor`
- `tower::ServiceBuilder::map_request`
- `tower::ServiceBuilder::map_response`
- `tower::ServiceBuilder::then`
- `tower::ServiceBuilder::and_then`
- `tower::Service` (最大の制御)

<https://github.com/tower-rs/tower/blob/master/guides/building-a-middleware-from-scratch.md>

## おわりに

TODO
