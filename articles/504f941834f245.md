---
emoji: "ğŸ§ª"
publication_name: "doctormate"
published: true
published_at: 2025-12-29 12:00
title: "axum crate ã® Router::merge ã¨ nest"
topics: ["rust"]
type: "tech"
---

[å‰å›ã¯ axum crate ã®ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦æ›¸ãã¾ã—ãŸ](https://zenn.dev/doctormate/articles/766e4c71d4970f)ã€‚

ä»Šå›ã¯ axum crate ã® Router::merge ã¨ nest ã«ã¤ã„ã¦æ›¸ãã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## Router::merge ã¨ Router::nest ã¨ã¯

`Router::merge` ã¨ `Router::nest` ã¨ã¯ã€ `Router` ã‚’ merge ã—ãŸã‚Š nest ã—ãŸã‚Šã™ã‚‹ã‚‚ã®ã§ã™ã€‚ `Router` ã‚’è¤‡æ•°ã®ç®‡æ‰€ã§å®šç¾©ã—ã€ãã‚Œã‚’çµ±åˆã™ã‚‹éš›ã«ä½¿ç”¨ã—ã¾ã™ã€‚

`Router::merge` ã¯ãƒ•ãƒ©ãƒƒãƒˆã«çµ±åˆã—ã€ `Router::nest` ã¯å…¥ã‚Œå­ã®å½¢ã«çµ±åˆã—ã¾ã™ã€‚

ãŸã¨ãˆã° `Router::merge` ãªã‚‰â†“ã‚’ãƒ•ãƒ©ãƒƒãƒˆã«çµ±åˆã™ã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã€‚

- `/a1`, `/b/1` ã‚’æ‰±ã† `1` ç³» (?) `Router`
- `/a2`, `/b/2` ã‚’æ‰±ã† `2` ç³» (?) `Router`

ãŸã¨ãˆã° `Router::nest` ãªã‚‰â†“ã‚’å…¥ã‚Œå­ã®å½¢ã«çµ±åˆã™ã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã€‚

- `/a1`, `/a2` ã‚’æ‰±ã† `a` ç³» (?) `Router`
- `/1`, `/2` ã‚’æ‰±ã† `b` ç³» (?) `Router` ã‚’ `/b` ã«å…¥ã‚Œå­ã®å½¢ã§

ãã‚“ãªã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

ã©ã†ã„ã†å˜ä½ã§ `Router` ã‚’å®šç¾©ã™ã‚‹ã‹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¤æ–­ãªã®ã§ã€è‡ªç”±åº¦ã‚’ã‚‚ãŸã›ã¦ã„ã‚‹ã‚ã‘ã§ã™ã­ã€‚

## Router::merge

`Router::merge` ã®è©³ç´°ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.merge>

```rust
pub fn merge<R>(self, other: R) -> Self
where
    R: Into<Router<S>>,
```

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/src/axum/routing/mod.rs.html#252-300>

`path_router` ã¯å†…éƒ¨å®Ÿè£…ã§ã‚ã‚‹ `PathRouter::merge` ã«ã¾ã‹ã›ã¦ã„ã¾ã™ã€‚

`fallback_router` ã¯ä¸¡æ–¹ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ panic ã«ã€ãã†ã§ãªã‘ã‚Œã°ã‚ˆã—ãªã«ãƒãƒ¼ã‚¸ã—ã¦ãã‚Œãã†ã§ã™ã€‚

ä¸¡æ–¹ã« fallback router ãŒã‚ã‚‹ã¨ panic ã™ã‚‹ä»•æ§˜ã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚‚è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

fallback router ã¯ãƒ«ãƒ¼ãƒˆã«ãƒãƒƒãƒã—ãªã‹ã£ãŸå ´åˆã«ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‹ã‚‰ã€ä¸€æ–¹ãŒä½¿ç”¨ã•ã‚Œã¦ã—ã¾ã†ã¨ä»–æ–¹ãŒä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã¯ãªã„ã®ã§ 2 ã¤ã‚ã£ã¦ã‚‚å›°ã‚‹ã‹ã‚‰ã§ã™ã­ã€‚

æ¬¡ã« `PathRouter::merge` ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L162-L204>

`other` å´ã® `routes` ã‚’èµ°æŸ»ã—ã¦ `self.route()` ã§è¿½åŠ ã—ã¦ã„ã¾ã™ã­ã€‚ [`route` ã«ã¤ã„ã¦ã¯éå»ã«è¦‹ã¦ã„ã¾ã™](https://zenn.dev/doctormate/articles/7ccac91c3773d5)ã­ã€‚

## Router::nest

`Router::nest` ã®è©³ç´°ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.nest>

```rust
pub fn nest(self, path: &str, router: Router<S>) -> Self
```

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã€‚

<https://docs.rs/axum/0.8.4/src/axum/routing/mod.rs.html#209-231>

`Router::nest` ã¯ `path_router` ã‚‚ `fallback_router` ã‚‚å…±ã« `nest` ã•ã‚Œã¦ã„ã¾ã™ã€‚

`Router::nest` ã® fallback router ã¯å…¥ã‚Œå­ã«ã•ã‚ŒãŸå´ã®ãƒ‘ã‚¹ã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã¯ãã¡ã‚‰ã® fallback ãŒå„ªå…ˆã•ã‚Œã‚‹ã®ã§ã€ä¸¡æ–¹ã«ã‚ã£ã¦ã‚‚å•é¡Œãªã„ã§ã™ã­ã€‚

æ¬¡ã« `PathRouter::nest` ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L206-L244>

`Router::merge` ã¨åŒæ§˜ã« `self.route()` ã—ã¦ã„ãã®ã§ã™ãŒã€ `path_for_nested_route` ã§ãƒ‘ã‚¹ã‚’æ›¸ãæ›ãˆã¦ã„ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L535-L546>

ç´ æœ´ãªæ›¸ãæ›ãˆã§ã™ã­ã€‚

```rust
pub(crate) fn path_for_nested_route<'a>(prefix: &'a str, path: &'a str) -> Cow<'a, str> {
    debug_assert!(prefix.starts_with('/'));
    debug_assert!(path.starts_with('/'));


    if prefix.ends_with('/') {
        format!("{prefix}{}", path.trim_start_matches('/')).into()
    } else if path == "/" {
        prefix.into()
    } else {
        format!("{prefix}{path}").into()
    }
}
```

ä½™è«‡ã§ã™ãŒ [`debug_assert` macro](https://doc.rust-lang.org/std/macro.debug_assert.html) ã€ä¾¿åˆ©ãã†ã§ã™ã­ã€‚å®Ÿè¡Œã‚³ã‚¹ãƒˆãŒå¤§ã—ãŸã“ã¨ãªã‘ã‚Œã° `assert!` ã®ã»ã†ãŒå®‰å¿ƒã§ããã†ã§ã™ãŒã€‚

## ç´°ã‹ã„ç‚¹: state ã®æ‰±ã„

ã•ã¦ã€ãŠãŠã¾ã‹ã«ã¯æŠŠæ¡ã—ãŸã¨ã“ã‚ã§ç´°ã‹ã„ã¨ã“ã‚ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚ state ã®æ‰±ã„ã§ã™ã­ã€‚

`Router::merge` ã‚‚ `Router::nest` ã‚‚ state ã®å‹ãŒä¸€è‡´ã—ãªã„ã¨ã„ã‘ã¾ã›ã‚“ã€‚

ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å…¨ä½“ã¯ <https://github.com/bouzuya/rust-examples/blob/8912fd78db7d43348e89371dc270132d3bcafb7b/axum7/src/main.rs> ã«ç½®ã„ã¦ã„ã¾ã™ã€‚

```rust
#[derive(Clone)]
struct StateA {
    a: String,
}

fn router_a() -> axum::Router<StateA> {
    axum::Router::new()
        .route("/a/1", axum::routing::get(|axum::extract::State(StateA { a }): axum::extract::State<StateA>| async move { a }))
}

#[derive(Clone)]
struct StateB {
    b: String,
}

fn router_b() -> axum::Router<StateB> {
    axum::Router::new()
        .route("/b/1", axum::routing::get(|axum::extract::State(StateB { b }): axum::extract::State<StateB>| async move { b }))
}

fn router() -> axum::Router<()> {
    axum::Router::new()
        .merge(router_a().with_state(StateA {
            a: "a_1".to_owned(),
        }))
        .merge(router_b().with_state(StateB {
            b: "b_1".to_owned(),
        }))
}

async fn f(path: &str, status: axum::http::StatusCode, body: &str) -> anyhow::Result<()> {
    let router = router();
    let request = axum::http::Request::builder()
        .uri(path)
        .body(axum::body::Body::empty())?;
    let response = send_request(router, request).await?;
    assert_eq!(response.status(), status);
    assert_eq!(response.into_body_string().await?, body);
    Ok(())
}
f("/a/1", axum::http::StatusCode::OK, "a_1").await?;
f("/b/1", axum::http::StatusCode::OK, "b_1").await?;
f("/c/1", axum::http::StatusCode::NOT_FOUND, "").await?;
```

`merge` ã®ç®‡æ‰€ã§ `with_state` ã§ `Router<StateA>` ã‚’ `Router<()>` ã«ã€ `Router<StateB>` ã‚’ `Router<()>` ã«å¤‰ãˆã‚‹ã“ã¨ã§å‹ã‚’åˆã‚ã›ã¦ã„ã¾ã™ã€‚

### ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ä¾‹

ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ç”¨ã—ã¦ä¸€è‡´ã•ã›ã‚‹ã®ã‚‚æ‰‹ã§ã™ã€‚ãƒ‰ã‚¯ã‚¿ãƒ¼ãƒ¡ã‚¤ãƒˆæ ªå¼ä¼šç¤¾ã§ã¯ã“ã®æ–¹æ³•ã‚’æ¡ç”¨ã—ã¦ã„ãŸã‚Šã—ã¾ã™ã€‚

```rust
trait StateTraitA {
    fn a(&self) -> String;
}

fn router_a<S: StateTraitA + Clone + Send + Sync + 'static>() -> axum::Router<S> {
    axum::Router::new().route(
        "/a/1",
        axum::routing::get(
            |axum::extract::State(s): axum::extract::State<S>| async move { s.a() },
        ),
    )
}

trait StateTraitB {
    fn b(&self) -> String;
}

fn router_b<S: StateTraitB + Clone + Send + Sync + 'static>() -> axum::Router<S> {
    axum::Router::new().route(
        "/b/1",
        axum::routing::get(
            |axum::extract::State(s): axum::extract::State<S>| async move { s.b() },
        ),
    )
}

#[derive(Clone)]
struct State {
    a: String,
    b: String,
}

impl StateTraitA for State {
    fn a(&self) -> String {
        self.a.clone()
    }
}

impl StateTraitB for State {
    fn b(&self) -> String {
        self.b.clone()
    }
}

fn router() -> axum::Router<()> {
    axum::Router::new()
        .merge(router_a())
        .merge(router_b())
        .with_state(State {
            a: "a_1".to_owned(),
            b: "b_1".to_owned(),
        })
}

async fn f(path: &str, status: axum::http::StatusCode, body: &str) -> anyhow::Result<()> {
    let router = router();
    let request = axum::http::Request::builder()
        .uri(path)
        .body(axum::body::Body::empty())?;
    let response = send_request(router, request).await?;
    assert_eq!(response.status(), status);
    assert_eq!(response.into_body_string().await?, body);
    Ok(())
}
f("/a/1", axum::http::StatusCode::OK, "a_1").await?;
f("/b/1", axum::http::StatusCode::OK, "b_1").await?;
f("/c/1", axum::http::StatusCode::NOT_FOUND, "").await?;
```

## ç´°ã‹ã„ç‚¹: é‡è¤‡ã—ãŸãƒ«ãƒ¼ãƒˆã®æ‰±ã„

`Router::merge` ã‚‚ `Router::nest` ã‚‚é‡è¤‡ã—ãŸãƒ«ãƒ¼ãƒˆã‚’å®šç¾©ã™ã‚‹ã¨ panic ã—ã¾ã™ã€‚ `Router` ã‚’åˆ†æ•£ã—ã¦å®šç¾©ã—ã¦ã„ã‚‹ã¨ã†ã£ã‹ã‚ŠãŒã‚ã‚Šå¾—ã‚‹ã®ã§æ³¨æ„ãŒå¿…è¦ãã†ã§ã™ã€‚

```rust
#[test]
#[should_panic(expected = "Overlapping method route. Handler for `GET /a/1` already exists")]
fn test_nest_duplicate() {
    fn router_a() -> axum::Router<()> {
        axum::Router::new().route("/1", axum::routing::get(|| async { "nest a_1" }))
    }

    fn router() -> axum::Router<()> {
        axum::Router::new()
            .route("/a/1", axum::routing::get(|| async { "a_1" }))
            .nest("/a", router_a())
    }

    let _ = router();
}
```

## ç´°ã‹ã„ç‚¹: ãã®ä»–

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ˆã‚‹ã¨ã€ `.nest("/{*wildcard}", ...)` ã‚„ `.nest("", ...)` ã‚‚ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã‚ˆã†ã§ã™ã€‚

```rust
#[test]
#[should_panic(expected = "Invalid route: nested routes cannot contain wildcards (*)")]
fn test_wildcard() {
    let _ = axum::Router::<()>::new().nest("/{*wildcard}", axum::Router::new());
}
```

ã‚ã¨ã¯ `nest` ã§æŒ‡å®šã—ãŸå ´åˆã¯ `Path` ã®æŒ™å‹•ãŒé…ç½®ã«ã‚ˆã£ã¦å¤‰ã‚ã‚‹ã“ã¨ã‚„ `Uri` ã® prefix ãŒå‰Šã‚‰ã‚Œã‚‹ãªã©ã®è¨˜è¼‰ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ãŸã‚Šã¯ã‚ã¾ã‚Šç´°ã‹ã„æ¤œè¨¼ã¯ã§ãã¦ã„ã¾ã›ã‚“ã€‚

## ãŠã‚ã‚Šã«

`Router::merge` ã¨ `Router::nest` ã«ã¤ã„ã¦æ›¸ã„ã¦ã¿ã¾ã—ãŸã€‚ `Router` ã‚’ã„ãã¤ã‹ã«åˆ†å‰²ã—ã¦å®šç¾©ã—ã¦ãŠããŸã„ã‚±ãƒ¼ã‚¹ã¯ã¾ã¾ã‚ã‚‹ã®ã§ã“ã†ã„ã†æ©Ÿèƒ½ã¯ä¾¿åˆ©ã§ã™ã­ã€‚

æ¬¡å›ã¯ Router ã‹ã‚‰ Handler ã«é€²ã‚‚ã†ã‹ã¨æ€ã„ã¾ã™ã€‚
