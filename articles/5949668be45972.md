---
emoji: "ğŸ•Œ"
publication_name: "doctormate"
published: true
published_at: 2026-02-02 12:00
title: "axum crate ã® FromRequest ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…"
topics: ["rust"]
type: "tech"
---

# axum crate ã® FromRequestParts ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…

[å‰å›ã¯ axum crate ã® FromRequestParts ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…ã‚’è¦‹ã¾ã—ãŸ](https://zenn.dev/doctormate/articles/527857bab9cbf1)ã€‚

ä»Šå›ã¯ axum crate ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ Extractor ã®å®Ÿè£…ã€ç‰¹ã« `FromRequst` ã®ã‚‚ã®ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## axum crate ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ Extractor ã¨ã¯

axum ã«ãŠã‘ã‚‹ Extractor ã¨ã¯ `FromRequestParts` trait ã¾ãŸã¯ `FromRequest` trait ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã€€Extractor ã¯ axum crate æœ¬ä½“ãŒæä¾›ã—ã¦ã„ã‚‹ãã‚Œã‚‰ã® trait ã®å®Ÿè£…ã§ã™ã€‚

ä»Šå›ã¯ `FromRequest` ã®å®Ÿè£…ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚[å‰ã€…å›](https://zenn.dev/doctormate/articles/10745f66b57301)ã¨åŒæ§˜ã«ã€ `FromRequest` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹å®Ÿè£…ã‚’é †ã«è¦‹ã¦ã„ãã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html>

## impl&lt;S&gt; FromRequest&lt;S&gt; for String

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-String>

```rust
impl<S> FromRequest<S> for String
where
    S: Send + Sync,
{
    type Rejection = StringRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let bytes = Bytes::from_request(req, state)
            .await
            .map_err(|err| match err {
                BytesRejection::FailedToBufferBody(inner) => {
                    StringRejection::FailedToBufferBody(inner)
                }
            })?;

        let string = String::from_utf8(bytes.into()).map_err(InvalidUtf8::from_err)?;

        Ok(string)
    }
}
```

`Bytes` ã® `FromRequest` ã®å®Ÿè£…ã«å‡¦ç†ã‚’ä»»ã›ã¦ `Bytes` ã‚’å¾—ãŸã‚ã¨ã€ãã‚Œã‚’ `String::from_utf8` ã§ `String` ã«ã—ã¦è¿”ã™ã‚ˆã†ã§ã™ã€‚

å¤±æ•—æ™‚ã«ã¯ã‚¨ãƒ©ãƒ¼ã‚’å¤‰æ›ã—ã¦ã„ã¾ã™ã­ã€‚

ã¡ãªã¿ã« `StringRejection` ã¯ã“ã“ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ `composite_rejection` macro ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã¡ã‚‰ã‚‚å¾Œã§è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/rejection.rs#L79-L82>

### impl&lt;S&gt; FromRequest&lt;S&gt; for Bytes

é †åºãŒå‰å¾Œã—ã¦ã„ã¾ã™ãŒã€ `Bytes` ã®ãŸã‚ã®å®Ÿè£…ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Bytes>

```rust
impl<S> FromRequest<S> for Bytes
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let bytes = req
            .into_limited_body()
            .collect()
            .await
            .map_err(FailedToBufferBody::from_err)?
            .to_bytes();

        Ok(bytes)
    }
}
```

`http::Request<axum_core::body::Body>` ã® `into_limited_body` ã‚’ `collect` ã—ãŸã‚‚ã®ã‚’ `to_bytes` ã—ãŸã‚‚ã®ã€‚

`into_limited_body` ã¯ `RequestExt` trait ã§å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã§ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L330-L332>

```rust
fn into_limited_body(self) -> Body {
    self.with_limited_body().into_body()
}
```

`with_limited_body` ã¯ body ã®ä¸Šé™ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L316-L328>

```rust
fn with_limited_body(self) -> Request {
    // update docs in `axum-core/src/extract/default_body_limit.rs` and
    // `axum/src/docs/extract.md` if this changes
    const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb


    match self.extensions().get::<DefaultBodyLimitKind>().copied() {
        Some(DefaultBodyLimitKind::Disable) => self,
        Some(DefaultBodyLimitKind::Limit(limit)) => {
            self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
        }
        None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
    }
}
```

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚‚è¨˜è¼‰ãŒã‚ã‚‹ã¨ãŠã‚Š `DefaultBodyLimit` ã¨ã„ã† layer ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§å¤‰æ›´ã§ãã¾ã™ã€‚å†…éƒ¨çš„ã« `DefaultBodyLimitKind` ã‚’ req ã® extensions ã« insert ã™ã‚‹ã‚‚ã®ã«ãªã£ã¦ã„ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/default_body_limit.rs>

`http_body_util::Limited` ã¯ limit ã«é”ã—ãŸã‚‰ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹æ©Ÿèƒ½ã‚’æŒã£ãŸ Body ã§ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Limited.html>

æœ€åˆã® `req.into_limited_body().collect().await` ã«æˆ»ã‚Šã¾ã™ã€‚ `collect` ã¯ `axum::body::Body::collect` ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/body/struct.Body.html#method.collect>

ã“ã‚Œã¯ `http_body_util::combinators::Collect` ã‚’è¿”ã—ã¾ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/combinators/struct.Collect.html>

ã•ã‚‰ã«ã€ `Collect` ã‚’ `.await` ã™ã‚‹ã¨ `http_body_util::Collected` ãŒè¿”ã•ã‚Œã¾ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Collected.html>

`map_err` ã¯ skip ã—ã¦ã€ `to_bytes` ã—ã¦çµ‚ã‚ã‚Šã§ã™ã€‚ `to_bytes` ã®çµæœã¯ `Bytes` ã§ã™ã€‚

## impl&lt;S&gt; FromRequest&lt;S&gt; for BytesMut

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-BytesMut>

```rust
impl<S> FromRequest<S> for BytesMut
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let mut body = req.into_limited_body();
        let mut bytes = BytesMut::new();
        body_to_bytes_mut(&mut body, &mut bytes).await?;
        Ok(bytes)
    }
}

async fn body_to_bytes_mut(body: &mut Body, bytes: &mut BytesMut) -> Result<(), BytesRejection> {
    while let Some(frame) = body
        .frame()
        .await
        .transpose()
        .map_err(FailedToBufferBody::from_err)?
    {
        let Ok(data) = frame.into_data() else {
            return Ok(());
        };
        bytes.put(data);
    }

    Ok(())
}
```

`Body` ã‚’ `frame` ã§ frame å˜ä½ã«èª­ã‚“ã§ `BytesMut` ã« `put` ã—ã¦ã„ãã€æœ€å¾Œã¾ã§èª­ã‚“ã ã‚‰è¿”ã—ã¾ã™ã€‚

## impl&lt;S&gt; FromRequest&lt;S&gt; for Request&lt;Body&gt;

ã“ã‚Œã‚‚é †åºãŒå‰å¾Œã—ã¦ã„ãã†ã§ã™ãŒã€ã‚‚ã£ã¨ã‚‚åŸºæœ¬çš„ãª request ã‚’ãã®ã¾ã¾å¾—ã‚‹ Extractor ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Request%3CBody%3E>

```rust
impl<S> FromRequest<S> for Request
where
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        Ok(req)
    }
}
```

`FromRequest` ã«æ¸¡ã•ã‚ŒãŸ `Request` ã‚’è¿”ã™ã ã‘ã§ã™ã€‚

## impl&lt;S, T1, ... T16&gt; FromRequest&lt;S&gt; for (T1, ..., T16)

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-(T1,)>

```rust
all_the_tuples!(impl_from_request);
```

```rust

macro_rules! impl_from_request {
    (
        [$($ty:ident),*], $last:ident
    ) => {
        // ...

        // This impl must not be generic over M, otherwise it would conflict with the blanket
        // implementation of `FromRequest<S, Mut>` for `T: FromRequestParts<S>`.
        #[allow(non_snake_case, unused_mut, unused_variables)]
        impl<S, $($ty,)* $last> FromRequest<S> for ($($ty,)* $last,)
        where
            $( $ty: FromRequestParts<S> + Send, )*
            $last: FromRequest<S> + Send,
            S: Send + Sync,
        {
            type Rejection = Response;

            fn from_request(req: Request, state: &S) -> impl Future<Output = Result<Self, Self::Rejection>> {
                let (mut parts, body) = req.into_parts();

                async move {
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*

                    let req = Request::from_parts(parts, body);

                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;

                    Ok(($($ty,)* $last,))
                }
            }
        }
    };
}
```

[å‰å›](https://zenn.dev/doctormate/articles/527857bab9cbf1)ã¨åŒã˜ç®‡æ‰€ã§ã™ã€‚ãŸã ä»Šå›ã¯ `impl_from_request` å†…ã® `FromRequest` éƒ¨åˆ†ã‚’è¦‹ã¾ã™ã€‚

â€¦â€¦ã¨ã¯è¨€ãˆã€å¤§ããå¤‰ã‚ã‚‹ã‚‚ã®ã§ã¯ãªãã¦ã€å‰å›ã¨ã®é•ã„ã¯æœ€å¾Œã®è¦ç´ ã«å¯¾ã—ã¦ `from_request_parts` ã™ã‚‹ã‹ `from_request` ã™ã‚‹ã‹ã§ã™ã€‚ `FromRequestParts` ã®å ´åˆã¯ request body ã‚’æ¶ˆè²»ã—ã¦ã¯ã„ã‘ãªã„ã®ã§ `from_request_parts` ã™ã‚‹ã ã‘ã€‚ä»Šå›ã® `FromRequest` ã®å ´åˆã¯ `from_request` ã§ request body ã‚’æ¶ˆè²»ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Option&lt;T&gt;

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/option.rs.html#53-56>

```rust
impl<S, T> FromRequest<S> for Option<T>
where
    T: OptionalFromRequest<S>,
    S: Send + Sync,
{
    type Rejection = T::Rejection;

    async fn from_request(req: Request, state: &S) -> Result<Option<T>, Self::Rejection> {
        T::from_request(req, state).await
    }
}
```

ã“ã“ã‚‚å‰å›ã¨å¤§ããå¤‰ã‚ã‚‰ãšã€ `OptionalFromRequestParts` ãŒ `OptionalFromRequest` ã«ãªã£ãŸã‚‚ã®ã§ã™ã€‚

`OptionalFromRequest` ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.OptionalFromRequest.html>

```rust
/// Customize the behavior of `Option<Self>` as a [`FromRequest`] extractor.
pub trait OptionalFromRequest<S, M = private::ViaRequest>: Sized {
    /// If the extractor fails, it will use this "rejection" type.
    ///
    /// A rejection is a kind of error that can be converted into a response.
    type Rejection: IntoResponse;

    /// Perform the extraction.
    fn from_request(
        req: Request,
        state: &S,
    ) -> impl Future<Output = Result<Option<Self>, Self::Rejection>> + Send;
}
```

`Option` ã§ wrap ã•ã‚Œã¦ã„ã‚‹ãã‚‰ã„ã®é•ã„ã§ã™ã€‚

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Result&lt;T, &lt;T as FromRequest&lt;S&gt;&gt;::Rejection&gt;

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Result%3CT,+%3CT+as+FromRequest%3CS%3E%3E::Rejection%3E>

```rust
impl<S, T> FromRequest<S> for Result<T, T::Rejection>
where
    T: FromRequest<S>,
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        Ok(T::from_request(req, state).await)
    }
}
```

ã“ã“ã‚‚å‰å›ã¨å¤§ããå¤‰ã‚ã‚‰ãšã€ ã‚¨ãƒ©ãƒ¼ã‚’ `into_response` ã›ãšã«ãã®ã¾ã¾ `Result` ã§è¿”ã™ã“ã¨ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å´ã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã ã‘ã§ã™ã­ã€‚

## impl&lt;S&gt; FromRequest&lt;S&gt; for Body

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Body>

```rust
impl<S> FromRequest<S> for Body
where
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        Ok(req.into_body())
    }
}
```

`Request` ã® `into_body` ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

<https://docs.rs/http/1.3.1/http/request/struct.Request.html#method.into_body>

```rust
pub fn into_body(self) -> T {
    self.body
}
```

## impl&lt;S&gt; FromRequest&lt;S&gt; for Multipart

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Multipart>

```rust
impl<S> FromRequest<S> for Multipart
where
    S: Send + Sync,
{
    type Rejection = MultipartRejection;

    async fn from_request(req: Request, _state: &S) -> Result<Self, Self::Rejection> {
        let boundary = parse_boundary(req.headers()).ok_or(InvalidBoundary)?;
        let stream = req.with_limited_body().into_body();
        let multipart = multer::Multipart::new(stream.into_data_stream(), boundary);
        Ok(Self { inner: multipart })
    }
}
```

```rust
fn parse_boundary(headers: &HeaderMap) -> Option<String> {
    let content_type = headers.get(CONTENT_TYPE)?.to_str().ok()?;
    multer::parse_boundary(content_type).ok()
}
```

å®Ÿè£…ã¨ã—ã¦ã¯ `multer` crate ã§ boundary, body ã‚’ parse ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚å¤–éƒ¨ã‹ã‚‰ã¯ axum ã® `Multipart` ã¨ã—ã¦ã—ã‹è¦‹ãˆãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

<https://docs.rs/multer/3.1.0/multer/struct.Multipart.html>

## impl&lt;S&gt; FromRequest&lt;S&gt; for RawForm

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-RawForm>

```rust
pub struct RawForm(pub Bytes);

impl<S> FromRequest<S> for RawForm
where
    S: Send + Sync,
{
    type Rejection = RawFormRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        if req.method() == Method::GET {
            if let Some(query) = req.uri().query() {
                return Ok(Self(Bytes::copy_from_slice(query.as_bytes())));
            }

            Ok(Self(Bytes::new()))
        } else {
            if !has_content_type(req.headers(), &mime::APPLICATION_WWW_FORM_URLENCODED) {
                return Err(InvalidFormContentType.into());
            }

            Ok(Self(Bytes::from_request(req, state).await?))
        }
    }
}
```

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«è¨˜è¼‰ã®ã¨ãŠã‚Šã€ GET ã®å ´åˆã¯ query string ã‚’è¦‹ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã­ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/struct.RawForm.html>

## impl&lt;S, T&gt; FromRequest&lt;S, ViaParts&gt; for T

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS,+ViaParts%3E-for-T>

```rust
impl<S, T> FromRequest<S, private::ViaParts> for T
where
    S: Send + Sync,
    T: FromRequestParts<S>,
{
    type Rejection = <Self as FromRequestParts<S>>::Rejection;

    fn from_request(
        req: Request,
        state: &S,
    ) -> impl Future<Output = Result<Self, Self::Rejection>> {
        let (mut parts, _) = req.into_parts();
        async move { Self::from_request_parts(&mut parts, state).await }
    }
}
```

`T: FromRequestParts<S>` ãªã®ã§ã€ `FromRequestParts` ãªã‚‰ `FromRequest` ã¨ã—ã¦å‹•ãã¨ã„ã†ã“ã¨ã§ã™ã­ã€‚

## impl&lt;T, S&gt; FromRequest&lt;S&gt; for Form&lt;T&gt;

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Form%3CT%3E>

```rust
pub struct Form<T>(pub T);

impl<T, S> FromRequest<S> for Form<T>
where
    T: DeserializeOwned,
    S: Send + Sync,
{
    type Rejection = FormRejection;

    async fn from_request(req: Request, _state: &S) -> Result<Self, Self::Rejection> {
        let is_get_or_head =
            req.method() == http::Method::GET || req.method() == http::Method::HEAD;

        match req.extract().await {
            Ok(RawForm(bytes)) => {
                let deserializer =
                    serde_urlencoded::Deserializer::new(form_urlencoded::parse(&bytes));
                let value = serde_path_to_error::deserialize(deserializer).map_err(
                    |err| -> FormRejection {
                        if is_get_or_head {
                            FailedToDeserializeForm::from_err(err).into()
                        } else {
                            FailedToDeserializeFormBody::from_err(err).into()
                        }
                    },
                )?;
                Ok(Form(value))
            }
            Err(RawFormRejection::BytesRejection(r)) => Err(FormRejection::BytesRejection(r)),
            Err(RawFormRejection::InvalidFormContentType(r)) => {
                Err(FormRejection::InvalidFormContentType(r))
            }
        }
    }
}
```

`RequestExt::extract` ã§ `RawForm` ã® `FromRequest` ã‚’å‹•ã‹ã—ã¦ bytes ã‚’å¾—ã¦ã€ `form_urlencoded` ã§ `application/x-www-form-urlencoded` ãª body ãªã„ã— query string ã‚’ parse ã—ã¦ã€ `serde_urlencoded` ã§ `serde::Deserialize` ãªå‹ã¸ã®å¤‰æ›ã‚’ã—ã¦ã„ã¾ã™ã€‚

`serde_path_to_error` crate ã§ã‚¨ãƒ©ãƒ¼ä½ç½®ã‚’ç‰¹å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã® crate çŸ¥ã‚‰ãªã‹ã£ãŸã§ã™ã€‚ã„ã„ã§ã™ã­ã€‚

`RequestExt::extract` ã¯â†“ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/trait.RequestExt.html#tymethod.extract>

## impl&lt;T, S&gt; FromRequest&lt;S&gt; for Json&lt;T&gt;

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html#impl-FromRequest%3CS%3E-for-Json%3CT%3E>

```rust
pub struct Json<T>(pub T);

impl<T, S> FromRequest<S> for Json<T>
where
    T: DeserializeOwned,
    S: Send + Sync,
{
    type Rejection = JsonRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        if !json_content_type(req.headers()) {
            return Err(MissingJsonContentType.into());
        }

        let bytes = Bytes::from_request(req, state).await?;
        Self::from_bytes(&bytes)
    }
}

// ...

impl<T> Json<T>
where
    T: DeserializeOwned,
{
    /// Construct a `Json<T>` from a byte slice. Most users should prefer to use the `FromRequest` impl
    /// but special cases may require first extracting a `Request` into `Bytes` then optionally
    /// constructing a `Json<T>`.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, JsonRejection> {
        // Extracted into separate fn so it's only compiled once for all T.
        fn make_rejection(err: serde_path_to_error::Error<serde_json::Error>) -> JsonRejection {
            match err.inner().classify() {
                serde_json::error::Category::Data => JsonDataError::from_err(err).into(),
                serde_json::error::Category::Syntax | serde_json::error::Category::Eof => {
                    JsonSyntaxError::from_err(err).into()
                }
                serde_json::error::Category::Io => {
                    if cfg!(debug_assertions) {
                        // we don't use `serde_json::from_reader` and instead always buffer
                        // bodies first, so we shouldn't encounter any IO errors
                        unreachable!()
                    } else {
                        JsonSyntaxError::from_err(err).into()
                    }
                }
            }
        }

        let deserializer = &mut serde_json::Deserializer::from_slice(bytes);

        match serde_path_to_error::deserialize(deserializer) {
            Ok(value) => Ok(Json(value)),
            Err(err) => Err(make_rejection(err)),
        }
    }
}
```

ã”ã¡ã‚ƒã”ã¡ã‚ƒã‚ã‚Šã¾ã™ãŒã€ `Bytes::from_request` ã—ã¦ `serde_json` ã® `from_slice` ã—ã¦å–ã‚Šå‡ºã—ã¦ã„ã¾ã™ã€‚ `Form` ã§ã‚‚å‡ºã¦ããŸ `serde_path_to_error` crate ãŒã“ã“ã§ã‚‚ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ axum crate ã® `FromRequest` ã®å®Ÿè£…ã‚’è¦‹ã¦ã„ãã¾ã—ãŸã€‚

æ¬¡å›ã¯ `IntoResponse` ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚
