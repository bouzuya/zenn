---
emoji: "ğŸ•Œ"
publication_name: "doctormate"
published: true
published_at: 2026-02-02 12:00
title: "axum crate ã® FromRequest ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…"
topics: ["rust"]
type: "tech"
---

# axum crate ã® FromRequestParts ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…

[å‰å›ã¯ axum crate ã® FromRequestParts ã®æ¨™æº–ã§æä¾›ã•ã‚Œã‚‹å®Ÿè£…ã‚’è¦‹ã¾ã—ãŸ](https://zenn.dev/doctormate/articles/527857bab9cbf1)ã€‚

ä»Šå›ã¯ axum crate ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ Extractor ã®å®Ÿè£…ã€ç‰¹ã« `FromRequst` ã®ã‚‚ã®ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## axum crate ã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ Extractor ã¨ã¯

axum ã«ãŠã‘ã‚‹ Extractor ã¨ã¯ `FromRequestParts` trait ã¾ãŸã¯ `FromRequest` trait ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã€€Extractor ã¯ axum crate æœ¬ä½“ãŒæä¾›ã—ã¦ã„ã‚‹ãã‚Œã‚‰ã® trait ã®å®Ÿè£…ã§ã™ã€‚

ä»Šå›ã¯ `FromRequest` ã®å®Ÿè£…ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚[å‰ã€…å›](https://zenn.dev/doctormate/articles/10745f66b57301)ã¨åŒæ§˜ã«ã€ `FromRequest` ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹å®Ÿè£…ã‚’é †ã«è¦‹ã¦ã„ãã¾ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html>

## impl&lt;S&gt; FromRequest&lt;S&gt; for String

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#116-118>

```rust
impl<S> FromRequest<S> for String
where
    S: Send + Sync,
{
    type Rejection = StringRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let bytes = Bytes::from_request(req, state)
            .await
            .map_err(|err| match err {
                BytesRejection::FailedToBufferBody(inner) => {
                    StringRejection::FailedToBufferBody(inner)
                }
            })?;

        let string = String::from_utf8(bytes.into()).map_err(InvalidUtf8::from_err)?;

        Ok(string)
    }
}
```

`Bytes` ã® `FromRequest` ã®å®Ÿè£…ã«å‡¦ç†ã‚’ä»»ã›ã¦ `Bytes` ã‚’å¾—ãŸã‚ã¨ã€ãã‚Œã‚’ `String::from_utf8` ã§ `String` ã«ã—ã¦è¿”ã™ã‚ˆã†ã§ã™ã€‚

å¤±æ•—æ™‚ã«ã¯ã‚¨ãƒ©ãƒ¼ã‚’å¤‰æ›ã—ã¦ã„ã¾ã™ã­ã€‚

ã¡ãªã¿ã« `StringRejection` ã¯ã“ã“ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ `composite_rejection` macro ãŒä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚ã“ã¡ã‚‰ã‚‚å¾Œã§è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/rejection.rs#L79-L82>

### impl&lt;S&gt; FromRequest&lt;S&gt; for Bytes

é †åºãŒå‰å¾Œã—ã¦ã„ã¾ã™ãŒã€ `Bytes` ã®ãŸã‚ã®å®Ÿè£…ã§ã™ã€‚

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#98-100>

```rust
impl<S> FromRequest<S> for Bytes
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let bytes = req
            .into_limited_body()
            .collect()
            .await
            .map_err(FailedToBufferBody::from_err)?
            .to_bytes();

        Ok(bytes)
    }
}
```

`http::Request<axum_core::body::Body>` ã® `into_limited_body` ã‚’ `collect` ã—ãŸã‚‚ã®ã‚’ `to_bytes` ã—ãŸã‚‚ã®ã€‚

`into_limited_body` ã¯ `RequestExt` trait ã§å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã§ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L330-L332>

```rust
fn into_limited_body(self) -> Body {
    self.with_limited_body().into_body()
}
```

`with_limited_body` ã¯ body ã®ä¸Šé™ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L316-L328>

```rust
fn with_limited_body(self) -> Request {
    // update docs in `axum-core/src/extract/default_body_limit.rs` and
    // `axum/src/docs/extract.md` if this changes
    const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb


    match self.extensions().get::<DefaultBodyLimitKind>().copied() {
        Some(DefaultBodyLimitKind::Disable) => self,
        Some(DefaultBodyLimitKind::Limit(limit)) => {
            self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
        }
        None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
    }
}
```

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚‚è¨˜è¼‰ãŒã‚ã‚‹ã¨ãŠã‚Š `DefaultBodyLimit` ã¨ã„ã† layer ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§å¤‰æ›´ã§ãã¾ã™ã€‚å†…éƒ¨çš„ã« `DefaultBodyLimitKind` ã‚’ req ã® extensions ã« insert ã™ã‚‹ã‚‚ã®ã«ãªã£ã¦ã„ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/default_body_limit.rs>

`http_body_util::Limited` ã¯ limit ã«é”ã—ãŸã‚‰ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹æ©Ÿèƒ½ã‚’æŒã£ãŸ Body ã§ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Limited.html>

æœ€åˆã® `req.into_limited_body().collect().await` ã«æˆ»ã‚Šã¾ã™ã€‚ `collect` ã¯ `axum::body::Body::collect` ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/body/struct.Body.html#method.collect>

ã“ã‚Œã¯ `http_body_util::combinators::Collect` ã‚’è¿”ã—ã¾ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/combinators/struct.Collect.html>

ã•ã‚‰ã«ã€ `Collect` ã‚’ `.await` ã™ã‚‹ã¨ `http_body_util::Collected` ãŒè¿”ã•ã‚Œã¾ã™ã€‚

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Collected.html>

`map_err` ã¯ skip ã—ã¦ã€ `to_bytes` ã—ã¦çµ‚ã‚ã‚Šã§ã™ã€‚ `to_bytes` ã®çµæœã¯ `Bytes` ã§ã™ã€‚

## impl&lt;S&gt; FromRequest&lt;S&gt; for BytesMut

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#68-70>

```rust
impl<S> FromRequest<S> for BytesMut
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let mut body = req.into_limited_body();
        let mut bytes = BytesMut::new();
        body_to_bytes_mut(&mut body, &mut bytes).await?;
        Ok(bytes)
    }
}

async fn body_to_bytes_mut(body: &mut Body, bytes: &mut BytesMut) -> Result<(), BytesRejection> {
    while let Some(frame) = body
        .frame()
        .await
        .transpose()
        .map_err(FailedToBufferBody::from_err)?
    {
        let Ok(data) = frame.into_data() else {
            return Ok(());
        };
        bytes.put(data);
    }

    Ok(())
}
```

`Body` ã‚’ `frame` ã§ frame å˜ä½ã«èª­ã‚“ã§ `BytesMut` ã« `put` ã—ã¦ã„ãã€æœ€å¾Œã¾ã§èª­ã‚“ã ã‚‰è¿”ã—ã¾ã™ã€‚

## impl&lt;S&gt; FromRequest&lt;S&gt; for Request&lt;Body&gt;

ã“ã‚Œã‚‚é †åºãŒå‰å¾Œã—ã¦ã„ãã†ã§ã™ãŒã€ã‚‚ã£ã¨ã‚‚åŸºæœ¬çš„ãª request ã‚’ãã®ã¾ã¾å¾—ã‚‹ Extractor ã§ã™ã€‚

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#8-10>

```rust
impl<S> FromRequest<S> for Request
where
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        Ok(req)
    }
}
```

`FromRequest` ã«æ¸¡ã•ã‚ŒãŸ `Request` ã‚’è¿”ã™ã ã‘ã§ã™ã€‚

## impl&lt;S, T1, ... T16&gt; FromRequest&lt;S&gt; for (T1, ..., T16)

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/tuple.rs.html#74>

```rust
all_the_tuples!(impl_from_request);
```

```rust

macro_rules! impl_from_request {
    (
        [$($ty:ident),*], $last:ident
    ) => {
        // ...

        // This impl must not be generic over M, otherwise it would conflict with the blanket
        // implementation of `FromRequest<S, Mut>` for `T: FromRequestParts<S>`.
        #[allow(non_snake_case, unused_mut, unused_variables)]
        impl<S, $($ty,)* $last> FromRequest<S> for ($($ty,)* $last,)
        where
            $( $ty: FromRequestParts<S> + Send, )*
            $last: FromRequest<S> + Send,
            S: Send + Sync,
        {
            type Rejection = Response;

            fn from_request(req: Request, state: &S) -> impl Future<Output = Result<Self, Self::Rejection>> {
                let (mut parts, body) = req.into_parts();

                async move {
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*

                    let req = Request::from_parts(parts, body);

                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;

                    Ok(($($ty,)* $last,))
                }
            }
        }
    };
}
```

[å‰å›](https://zenn.dev/doctormate/articles/527857bab9cbf1)ã¨åŒã˜ç®‡æ‰€ã§ã™ã€‚ãŸã ä»Šå›ã¯ `impl_from_request` å†…ã® `FromRequest` éƒ¨åˆ†ã‚’è¦‹ã¾ã™ã€‚

â€¦â€¦ã¨ã¯è¨€ãˆã€å¤§ããå¤‰ã‚ã‚‹ã‚‚ã®ã§ã¯ãªãã¦ã€å‰å›ã¨ã®é•ã„ã¯æœ€å¾Œã®è¦ç´ ã«å¯¾ã—ã¦ `from_request_parts` ã™ã‚‹ã‹ `from_request` ã™ã‚‹ã‹ã§ã™ã€‚ `FromRequestParts` ã®å ´åˆã¯ request body ã‚’æ¶ˆè²»ã—ã¦ã¯ã„ã‘ãªã„ã®ã§ `from_request_parts` ã™ã‚‹ã ã‘ã€‚ä»Šå›ã® `FromRequest` ã®å ´åˆã¯ `from_request` ã§ request body ã‚’æ¶ˆè²»ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Option&lt;T&gt;

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/option.rs.html#53-56>

```rust
impl<S, T> FromRequest<S> for Option<T>
where
    T: OptionalFromRequest<S>,
    S: Send + Sync,
{
    type Rejection = T::Rejection;

    async fn from_request(req: Request, state: &S) -> Result<Option<T>, Self::Rejection> {
        T::from_request(req, state).await
    }
}
```

ã“ã“ã‚‚å‰å›ã¨å¤§ããå¤‰ã‚ã‚‰ãšã€ `OptionalFromRequestParts` ãŒ `OptionalFromRequest` ã«ãªã£ãŸã‚‚ã®ã§ã™ã€‚

`OptionalFromRequest` ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/option.rs.html#25>

```rust
/// Customize the behavior of `Option<Self>` as a [`FromRequest`] extractor.
pub trait OptionalFromRequest<S, M = private::ViaRequest>: Sized {
    /// If the extractor fails, it will use this "rejection" type.
    ///
    /// A rejection is a kind of error that can be converted into a response.
    type Rejection: IntoResponse;

    /// Perform the extraction.
    fn from_request(
        req: Request,
        state: &S,
    ) -> impl Future<Output = Result<Option<Self>, Self::Rejection>> + Send;
}
```

`Option` ã§ wrap ã•ã‚Œã¦ã„ã‚‹ãã‚‰ã„ã®é•ã„ã§ã™ã€‚

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Result&lt;T, &lt;T as FromRequest&lt;S&gt;&gt;::Rejection&gt;

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/mod.rs.html#125-128>

```rust
impl<S, T> FromRequest<S> for Result<T, T::Rejection>
where
    T: FromRequest<S>,
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        Ok(T::from_request(req, state).await)
    }
}
```

ã“ã“ã‚‚å‰å›ã¨å¤§ããå¤‰ã‚ã‚‰ãšã€ ã‚¨ãƒ©ãƒ¼ã‚’ `into_response` ã›ãšã«ãã®ã¾ã¾ `Result` ã§è¿”ã™ã“ã¨ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å´ã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã ã‘ã§ã™ã­ã€‚

## 

## 

- [ ] `impl<S> FromRequest<S> for Body`
- [ ] `impl<S> FromRequest<S> for Multipart`
- [ ] `impl<S> FromRequest<S> for RawForm`
- [ ] `impl<S, T> FromRequest<S, ViaParts> for T`
- [ ] `impl<T, S> FromRequest<S> for Form<T>`
- [ ] `impl<T, S> FromRequest<S> for Json<T>`
- [ ] composite_rejection macro
- [ ] bytes crate
