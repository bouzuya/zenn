---
emoji: "🕌"
publication_name: "doctormate"
published: true
published_at: 2026-02-02 12:00
title: "axum crate の FromRequest の標準で提供される実装"
topics: ["rust"]
type: "tech"
---

# axum crate の FromRequestParts の標準で提供される実装

[前回は axum crate の FromRequestParts の標準で提供される実装を見ました](https://zenn.dev/doctormate/articles/527857bab9cbf1)。

今回は axum crate のビルトイン Extractor の実装、特に `FromRequst` のものを見ていきます。

今回も axum crate のバージョンは 0.8.4 です。

## axum crate のビルトイン Extractor とは

axum における Extractor とは `FromRequestParts` trait または `FromRequest` trait を実装しているものです。ビルトイン　Extractor は axum crate 本体が提供しているそれらの trait の実装です。

今回は `FromRequest` の実装を見ていきます。[前々回](https://zenn.dev/doctormate/articles/10745f66b57301)と同様に、 `FromRequest` のドキュメントにある実装を順に見ていきます。

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html>

## impl&lt;S&gt; FromRequest&lt;S&gt; for String

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#116-118>

```rust
impl<S> FromRequest<S> for String
where
    S: Send + Sync,
{
    type Rejection = StringRejection;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        let bytes = Bytes::from_request(req, state)
            .await
            .map_err(|err| match err {
                BytesRejection::FailedToBufferBody(inner) => {
                    StringRejection::FailedToBufferBody(inner)
                }
            })?;

        let string = String::from_utf8(bytes.into()).map_err(InvalidUtf8::from_err)?;

        Ok(string)
    }
}
```

`Bytes` の `FromRequest` の実装に処理を任せて `Bytes` を得たあと、それを `String::from_utf8` で `String` にして返すようです。

失敗時にはエラーを変換していますね。

ちなみに `StringRejection` はここで定義されています。 `composite_rejection` macro が使われています。こちらも後で見ます。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/rejection.rs#L79-L82>

### impl&lt;S&gt; FromRequest&lt;S&gt; for Bytes

順序が前後していますが、 `Bytes` のための実装です。

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#98-100>

```rust
impl<S> FromRequest<S> for Bytes
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let bytes = req
            .into_limited_body()
            .collect()
            .await
            .map_err(FailedToBufferBody::from_err)?
            .to_bytes();

        Ok(bytes)
    }
}
```

`http::Request<axum_core::body::Body>` の `into_limited_body` を `collect` したものを `to_bytes` したもの。

`into_limited_body` は `RequestExt` trait で定義されたものです。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L330-L332>

```rust
fn into_limited_body(self) -> Body {
    self.with_limited_body().into_body()
}
```

`with_limited_body` は body の上限を設定するためのものです。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/ext_traits/request.rs#L316-L328>

```rust
fn with_limited_body(self) -> Request {
    // update docs in `axum-core/src/extract/default_body_limit.rs` and
    // `axum/src/docs/extract.md` if this changes
    const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb


    match self.extensions().get::<DefaultBodyLimitKind>().copied() {
        Some(DefaultBodyLimitKind::Disable) => self,
        Some(DefaultBodyLimitKind::Limit(limit)) => {
            self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
        }
        None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
    }
}
```

ドキュメントにも記載があるとおり `DefaultBodyLimit` という layer を設定することで変更できます。内部的に `DefaultBodyLimitKind` を req の extensions に insert するものになっています。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum-core/src/extract/default_body_limit.rs>

`http_body_util::Limited` は limit に達したらエラーにする機能を持った Body です。

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Limited.html>

最初の `req.into_limited_body().collect().await` に戻ります。 `collect` は `axum::body::Body::collect` です。

<https://docs.rs/axum/0.8.4/axum/body/struct.Body.html#method.collect>

これは `http_body_util::combinators::Collect` を返します。

<https://docs.rs/http-body-util/0.1.3/http_body_util/combinators/struct.Collect.html>

さらに、 `Collect` を `.await` すると `http_body_util::Collected` が返されます。

<https://docs.rs/http-body-util/0.1.3/http_body_util/struct.Collected.html>

`map_err` は skip して、 `to_bytes` して終わりです。 `to_bytes` の結果は `Bytes` です。

## impl&lt;S&gt; FromRequest&lt;S&gt; for BytesMut

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#68-70>

```rust
impl<S> FromRequest<S> for BytesMut
where
    S: Send + Sync,
{
    type Rejection = BytesRejection;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        let mut body = req.into_limited_body();
        let mut bytes = BytesMut::new();
        body_to_bytes_mut(&mut body, &mut bytes).await?;
        Ok(bytes)
    }
}

async fn body_to_bytes_mut(body: &mut Body, bytes: &mut BytesMut) -> Result<(), BytesRejection> {
    while let Some(frame) = body
        .frame()
        .await
        .transpose()
        .map_err(FailedToBufferBody::from_err)?
    {
        let Ok(data) = frame.into_data() else {
            return Ok(());
        };
        bytes.put(data);
    }

    Ok(())
}
```

`Body` を `frame` で frame 単位に読んで `BytesMut` に `put` していき、最後まで読んだら返します。

## impl&lt;S&gt; FromRequest&lt;S&gt; for Request&lt;Body&gt;

これも順序が前後していそうですが、もっとも基本的な request をそのまま得る Extractor です。

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/request_parts.rs.html#8-10>

```rust
impl<S> FromRequest<S> for Request
where
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
        Ok(req)
    }
}
```

`FromRequest` に渡された `Request` を返すだけです。

## impl&lt;S, T1, ... T16&gt; FromRequest&lt;S&gt; for (T1, ..., T16)

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/tuple.rs.html#74>

```rust
all_the_tuples!(impl_from_request);
```

```rust

macro_rules! impl_from_request {
    (
        [$($ty:ident),*], $last:ident
    ) => {
        // ...

        // This impl must not be generic over M, otherwise it would conflict with the blanket
        // implementation of `FromRequest<S, Mut>` for `T: FromRequestParts<S>`.
        #[allow(non_snake_case, unused_mut, unused_variables)]
        impl<S, $($ty,)* $last> FromRequest<S> for ($($ty,)* $last,)
        where
            $( $ty: FromRequestParts<S> + Send, )*
            $last: FromRequest<S> + Send,
            S: Send + Sync,
        {
            type Rejection = Response;

            fn from_request(req: Request, state: &S) -> impl Future<Output = Result<Self, Self::Rejection>> {
                let (mut parts, body) = req.into_parts();

                async move {
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*

                    let req = Request::from_parts(parts, body);

                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;

                    Ok(($($ty,)* $last,))
                }
            }
        }
    };
}
```

[前回](https://zenn.dev/doctormate/articles/527857bab9cbf1)と同じ箇所です。ただ今回は `impl_from_request` 内の `FromRequest` 部分を見ます。

……とは言え、大きく変わるものではなくて、前回との違いは最後の要素に対して `from_request_parts` するか `from_request` するかです。 `FromRequestParts` の場合は request body を消費してはいけないので `from_request_parts` するだけ。今回の `FromRequest` の場合は `from_request` で request body を消費してしまいます。

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Option&lt;T&gt;

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/option.rs.html#53-56>

```rust
impl<S, T> FromRequest<S> for Option<T>
where
    T: OptionalFromRequest<S>,
    S: Send + Sync,
{
    type Rejection = T::Rejection;

    async fn from_request(req: Request, state: &S) -> Result<Option<T>, Self::Rejection> {
        T::from_request(req, state).await
    }
}
```

ここも前回と大きく変わらず、 `OptionalFromRequestParts` が `OptionalFromRequest` になったものです。

`OptionalFromRequest` は次のように定義されています。

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/option.rs.html#25>

```rust
/// Customize the behavior of `Option<Self>` as a [`FromRequest`] extractor.
pub trait OptionalFromRequest<S, M = private::ViaRequest>: Sized {
    /// If the extractor fails, it will use this "rejection" type.
    ///
    /// A rejection is a kind of error that can be converted into a response.
    type Rejection: IntoResponse;

    /// Perform the extraction.
    fn from_request(
        req: Request,
        state: &S,
    ) -> impl Future<Output = Result<Option<Self>, Self::Rejection>> + Send;
}
```

`Option` で wrap されているくらいの違いです。

## impl&lt;S, T&gt; FromRequest&lt;S&gt; for Result&lt;T, &lt;T as FromRequest&lt;S&gt;&gt;::Rejection&gt;

<https://docs.rs/axum-core/0.5.2/src/axum_core/extract/mod.rs.html#125-128>

```rust
impl<S, T> FromRequest<S> for Result<T, T::Rejection>
where
    T: FromRequest<S>,
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        Ok(T::from_request(req, state).await)
    }
}
```

ここも前回と大きく変わらず、 エラーを `into_response` せずにそのまま `Result` で返すことでユーザー側でエラーハンドリングできるようにしただけですね。

## 

## 

- [ ] `impl<S> FromRequest<S> for Body`
- [ ] `impl<S> FromRequest<S> for Multipart`
- [ ] `impl<S> FromRequest<S> for RawForm`
- [ ] `impl<S, T> FromRequest<S, ViaParts> for T`
- [ ] `impl<T, S> FromRequest<S> for Form<T>`
- [ ] `impl<T, S> FromRequest<S> for Json<T>`
- [ ] composite_rejection macro
- [ ] bytes crate
