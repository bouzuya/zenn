---
emoji: "🔥"
publication_name: "doctormate"
published: true
published_at: 2026-03-09 12:00
title: "axum crate の Middleware (2) axum::middleware::from_fn"
topics: ["rust"]
type: "tech"
---

[前回は axum crate の middleware の適用順序を見ました](https://zenn.dev/doctormate/articles/363f753577c1f5)。

今回は axum の middleware のドキュメントの後半を見ていきます。

今回も axum crate のバージョンは 0.8.4 です。

## axum の middleware を書くには

まずはドキュメントを見ていきます。今回は Writing middleware 以降です。

<https://docs.rs/axum/0.8.4/axum/middleware/index.html>

いくつかの方法が使うべき場面とともに書かれています。まずはざっと見ます。

- [`axum::middleware::from_fn`](https://docs.rs/axum/0.8.4/axum/middleware/fn.from_fn.html)
    - async fn と `FromRequest(Parts)` と `IntoResponse` に加えて `Next` を使う関数から定義するもの
    - Future に慣れておらず、 async/await で書きたい
    - crate として公開せず、 axum のみに互換性があることを許容できる
    - `State` を使うなら [`axum::middleware::from_fn_with_state`](https://docs.rs/axum/0.8.4/axum/middleware/fn.from_fn_with_state.html)
- [`axum::middleware::from_extractor`](https://docs.rs/axum/0.8.4/axum/middleware/fn.from_extractor.html)
    - Extractor から定義するもの
    - Extractor と Middleware の両方で使いたい
    - crate として公開せず、 axum のみに互換性があることを許容できる
    - Middleware としてだけ使うなら `axum::middleware::from_fn` のほうが良い
- tower's combinators
    - `tower::ServiceBuilder` のメソッドによるもの
    - 例
        - [`tower::ServiceBuilder::map_request`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.map_request)
        - [`tower::ServiceBuilder::map_response`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.map_response)
        - [`tower::ServiceBuilder::then`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.then)
        - [`tower::ServiceBuilder::and_then`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.and_then)
    - ヘッダーの追加などアドホックなもの
    - crate として公開しないもの
- `tower::Service` and `Pin<Box<dyn Future>>`
    - `tower::Service` を実装しており最大の制御を得られる
    - 設定可能にしたい
    - crate として公開したい
    - Future に慣れていない
- `tower::Service` and custom futures
    - Middleware のオーバーヘッドを抑えたい
    - `tower::Service` を実装しており最大の制御を得られる
    - 設定可能にしたい
    - crate として公開したい
    - Future に慣れている or 慣れたい
    - <https://github.com/tower-rs/tower/blob/master/guides/building-a-middleware-from-scratch.md>

## axum::middleware::from_fn

次は、それぞれを見ていきます。

`axum::middleware::from_fn` のドキュメントには、この関数がどのような関数から Middleware をつくれるかが書いてあります。

<https://docs.rs/axum/0.8.4/axum/middleware/fn.from_fn.html>

1. `async fn` であること
2. 0 個以上の `FromRequestParts` Extractor を取ること
3. 後ろから 2 番目の引数として 1 個の `FromRequest` Extractor を取ること
4. 最後の引数として `Next` を取ること
5. `IntoResponse` の実装を返すこと

Handler とわりと似ていますね。違いは `Next` があることや、 `FromRequest` 実装を必須とする点でしょうか。あと `State` のときは `from_fn_with_state` を使えということなので、おそらく `State` も指定できないでしょう。

```rust
pub fn from_fn<F, T>(f: F) -> FromFnLayer<F, (), T> {
    from_fn_with_state((), f)
}
```

実装は `from_fn_with_state` を `State` が `()` であるものとして丸投げですね。

[`axum::middleware::from_fn_with_state`](https://docs.rs/axum/0.8.4/axum/middleware/fn.from_fn_with_state.html)

```rust
pub fn from_fn_with_state<F, S, T>(state: S, f: F) -> FromFnLayer<F, S, T> {
    FromFnLayer {
        f,
        state,
        _extractor: PhantomData,
    }
}
```

`from_fn_with_state` は `FromFnLayer` を返しており、名前からすると Layer でしょう。

そこで `impl Layer for FromFnLayer` の実装を確認します。

```rust

impl<S, I, F, T> Layer<I> for FromFnLayer<F, S, T>
where
    F: Clone,
    S: Clone,
{
    type Service = FromFn<F, S, I, T>;

    fn layer(&self, inner: I) -> Self::Service {
        FromFn {
            f: self.f.clone(),
            state: self.state.clone(),
            inner,
            _extractor: PhantomData,
        }
    }
}
```

`impl Layer for FromFnLayer` は `FromFn` を返しています。 `Layer::Service` なので `FromFn` は `Service` を実装しているはずです。

そこで `impl Service for FromFn` の実装を確認します。

```rust
macro_rules! impl_service {
    (
        [$($ty:ident),*], $last:ident
    ) => {
        #[allow(non_snake_case, unused_mut)]
        impl<F, Fut, Out, S, I, $($ty,)* $last> Service<Request> for FromFn<F, S, I, ($($ty,)* $last,)>
        where
            F: FnMut($($ty,)* $last, Next) -> Fut + Clone + Send + 'static,
            $( $ty: FromRequestParts<S> + Send, )*
            $last: FromRequest<S> + Send,
            Fut: Future<Output = Out> + Send + 'static,
            Out: IntoResponse + 'static,
            I: Service<Request, Error = Infallible>
                + Clone
                + Send
                + Sync
                + 'static,
            I::Response: IntoResponse,
            I::Future: Send + 'static,
            S: Clone + Send + Sync + 'static,
        {
            type Response = Response;
            type Error = Infallible;
            type Future = ResponseFuture;

            fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                self.inner.poll_ready(cx)
            }

            fn call(&mut self, req: Request) -> Self::Future {
                let not_ready_inner = self.inner.clone();
                let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);

                let mut f = self.f.clone();
                let state = self.state.clone();
                let (mut parts, body) = req.into_parts();

                let future = Box::pin(async move {
                    $(
                        let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
                    )*

                    let req = Request::from_parts(parts, body);

                    let $last = match $last::from_request(req, &state).await {
                        Ok(value) => value,
                        Err(rejection) => return rejection.into_response(),
                    };

                    let inner = BoxCloneSyncService::new(MapIntoResponse::new(ready_inner));
                    let next = Next { inner };

                    f($($ty,)* $last, next).await.into_response()
                });

                ResponseFuture {
                    inner: future
                }
            }
        }
    };
}

all_the_tuples!(impl_service);
```

これはこのシリーズで何度も見た all_the_tuples での実装になります。

……とは言え、 `Next` の部分以外は説明されているとおりに `FromRequestParts` や `FromRequest` や `IntoResponse` などを処理する素直な実装という印象です。

`tower::util::BoxCloneSyncService` は追わないですが、名前どおりのものでしょう。

`axum::util::MapIntoResponse` もここでは追わないですが、 `IntoResponse` する `Future` を返す `Service` でした。

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/util.rs#L49>

`Next` は、次の Middleware を inner として持ち `run` で呼び出せるようになったものです。これも見たとおりです。

ここでは記事の量的に省略していますが、このあたりのソースコードを見ていると `tower::Service` 慣れ (?) が捗るので、追っておくのは良いことのように思います。

## おわりに

今回は axum の middleware のドキュメントの後半に入りました。全部は見れず `axum::middleware::from_fn` を読むところまでです。

実際に書いたりしたかったのですが (実は前回のコードで既に使用しています) 、今回は見送ろうと思います。

次回は他の Middleware を書く方法も見ていこうと思います。
