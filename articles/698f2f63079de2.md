---
emoji: "ğŸ‘»"
publication_name: "doctormate"
published: true
published_at: 2026-03-30 12:00
title: "axum crate ã® Middleware (5) tower::Service and Pin<Box<dyn Future>>"
topics: ["rust"]
type: "tech"
---

[å‰å›ã¯ axum ã® middleware ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã® Writing middleware ã‹ã‚‰ tower ã® combinator ã«ã¤ã„ã¦è¦‹ã¾ã—ãŸ](https://zenn.dev/doctormate/articles/9c757ab73eb2f1)ã€‚

ä»Šå›ã¯ axum ã® middleware ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰ `tower::Service` and `Pin<Box<dyn Future>>` ä»¥é™ã‚’èª­ã‚“ã§ã„ãã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## `tower::Service` and `Pin<Box<dyn Future>>` 

ã¾ãšã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã¾ã™ã€‚å‰å›ã¯  tower's combinators ã®ã¨ã“ã‚ã¾ã§ã ã£ãŸã®ã§ã€ãã®ç¶šãã® `tower::Service` and `Pin<Box<dyn Future>>` ã‹ã‚‰ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/middleware/index.html>

å‰å›ã‚‚ `tower::Service` ã§ã—ãŸãŒã€ä»Šå›ã‚‚ã€ã§ã™ã€‚å‰å›ã¯ `ServiceBuilder` ã‚’ä½¿ã£ãŸ combinator ã§ `tower::Service` ã«å‡¦ç†ã‚’è¿½åŠ ã™ã‚‹å½¢ã§ã—ãŸãŒã€ä»Šå›ã¯ `tower::Service` ã‚’æ‰‹å‹•ã§å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚ãŸã ã—ã€ç‹¬è‡ªã® `Future` ã®å®Ÿè£…ã¾ã§ã¯ã›ãšã€æ—¢å­˜ã® `Future` ã®å‰å¾Œã«å‡¦ç†ã‚’å…¥ã‚Œã‚‹ã‚ˆã†ã§ã™ã€‚

ä»Šå›ã® Middleware ã®æ›¸ãæ–¹ã®ç‰¹å¾´ã¨ã—ã¦ã¯

- `tower::Layer` ã§è¨­å®šã‚’å¤‰æ›´å¯èƒ½ãª Middleware ã«ã§ãã‚‹
- crate ã¨ã—ã¦å…¬é–‹ã§ãã‚‹
- ç‹¬è‡ªã® `Future` ã®å®Ÿè£…ã«æ…£ã‚Œã¦ã„ãªãã¦ã‚‚è‰¯ã„

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚³ãƒ¼ãƒ‰ä¾‹ãŒã¾ã‚‹ã£ã¨è¼‰ã£ã¦ã„ã¾ã™ã€‚

æ§‹é€ ä½“ã®å†…éƒ¨ã« `inner` ã¨ã—ã¦ä»– (æ¬¡) ã® `tower::Service` ã‚’ä¿æŒã—ã¦ãŠã‚Šã€ãã‚Œã‚’å‘¼ã³å‡ºã—ã¦â€¦â€¦ã¨ã™ã‚‹å½¢ã§ã™ã€‚

æœ€å¾Œã®å€¤ã‚’è¿”ã™éš›ã« `Box::pin(async { ... })` ã¨ã—ã¦ã€ `inner` ã®ç”Ÿæˆã—ãŸ future ã‚’ await ã—ã¦å¾—ã‚‰ã‚ŒãŸ response ã‚’å¿…è¦ãªã‚‰å¤‰æ›ã—ã¦è¿”ã™ã¨ã€‚ `inner` ã®å‘¼ã³å‡ºã—å‰ã« request ã‚’å¤‰æ›ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã­ã€‚

## è©¦ã—ã«æ›¸ã„ã¦ã¿ã‚‹

è©¦ã—ã«æ›¸ã„ã¦ã¿ã¾ã—ãŸã€‚â€¦â€¦ã¨ã¯è¨€ãˆã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã«ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«åŠ å·¥ or ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«åŠ å·¥ã‚’ãã‚Œãã‚Œè©¦ã—ãŸã ã‘ã§ã™ã€‚

<https://github.com/bouzuya/rust-examples/blob/8bea52ecc582fb63a08ea176541870487a28d94a/axum11/src/main.rs>

```rust
#[derive(Clone)]
struct MyLayer {
    name: &'static str,
}

impl MyLayer {
    fn with_name(name: &'static str) -> Self {
        Self { name }
    }
}

impl<S> tower::Layer<S> for MyLayer {
    type Service = MyMiddleware<S>;


    fn layer(&self, inner: S) -> Self::Service {
        MyMiddleware {
            inner,
            name: self.name,
        }
    }
}

#[derive(Clone)]
struct MyMiddleware<S> {
    inner: S,
    name: &'static str,
}

impl<S> tower::Service<axum::http::Request<axum::body::Body>> for MyMiddleware<S>
where
    S: tower::Service<
            axum::http::Request<axum::body::Body>,
            Response = axum::http::Response<axum::body::Body>,
        > + Send
        + 'static,
    S::Future: Send + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    // `BoxFuture` is a type alias for `Pin<Box<dyn Future + Send + 'a>>`
    type Future =
        futures_util::future::BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut request: axum::http::Request<axum::body::Body>) -> Self::Future {
        request
            .headers_mut()
            .insert("X-NAME", axum::http::HeaderValue::from_static(self.name));

        let future = self.inner.call(request);
        Box::pin(async move {
            let response: axum::http::Response<axum::body::Body> = future.await?;
            Ok(response)
        })
    }
}

async fn handler(header_map: axum::http::HeaderMap) -> String {
    format!("X-NAME: {:?}", header_map.get("X-NAME"))
}

let app = axum::Router::<()>::new()
    .route("/", axum::routing::get(handler))
    .layer(MyLayer::with_name("bouzuya"));
let response = send_request(
    app,
    axum::http::Request::builder()
        .method("GET")
        .uri("/")
        .body(axum::body::Body::empty())?,
)
.await?;
assert_eq!(response.status(), axum::http::StatusCode::OK);
assert_eq!(
    response.into_body_string().await?,
    "X-NAME: Some(\"bouzuya\")"
);
Ok(())
```

ã“ã¡ã‚‰ã®ä¾‹ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’åŠ å·¥ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ˜ãƒƒãƒ€ãƒ¼ã« `X-NAME` ã‚’è¿½åŠ ã—ã¾ã™ã€‚ä¸€å¿œ `MyLayer` ã«ã€Œè¨­å®šã€ã¨ã—ã¦ `name` ã‚’æŒãŸã›ã¦ã¿ã¾ã—ãŸã€‚ã¤ã¾ã‚‰ãªã„ä¾‹ã§ã™ãŒã€ç¢ºã‹ã«å‹•ä½œã—ãã†ã§ã™ã€‚

ä»Šåº¦ã¯ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’åŠ å·¥ã™ã‚‹ä¾‹ã§ã™ã€‚

```rust
#[derive(Clone)]
struct MyLayer;

impl<S> tower::Layer<S> for MyLayer {
    type Service = MyMiddleware<S>;

    fn layer(&self, inner: S) -> Self::Service {
        MyMiddleware { inner }
    }
}

#[derive(Clone)]
struct MyMiddleware<S> {
    inner: S,
}

impl<S> tower::Service<axum::http::Request<axum::body::Body>> for MyMiddleware<S>
where
    S: tower::Service<
            axum::http::Request<axum::body::Body>,
            Response = axum::http::Response<axum::body::Body>,
        > + Send
        + 'static,
    S::Future: Send + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    // `BoxFuture` is a type alias for `Pin<Box<dyn Future + Send + 'a>>`
    type Future =
        futures_util::future::BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, request: axum::http::Request<axum::body::Body>) -> Self::Future {
        let future = self.inner.call(request);
        Box::pin(async move {
            let mut response: axum::http::Response<axum::body::Body> = future.await?;
            *response.body_mut() = axum::body::Body::from("Updated Response Body");
            Ok(response)
        })
    }
}

let app = axum::Router::<()>::new()
    .route("/", axum::routing::get("Original Response"))
    .layer(MyLayer);
let response = send_request(
    app,
    axum::http::Request::builder()
        .method("GET")
        .uri("/")
        .body(axum::body::Body::empty())?,
)
.await?;
assert_eq!(response.status(), axum::http::StatusCode::OK);
assert_eq!(response.into_body_string().await?, "Updated Response Body");
Ok(())
```

ã“ã¡ã‚‰ã‚‚ã»ã¨ã‚“ã©åŒã˜ã§ã™ãŒã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’åŠ å·¥ã—ã¾ã—ãŸã€‚è¨­å®šæ©Ÿèƒ½ã¯å‰Šã‚Šã¾ã—ãŸã€‚

ã“ã®ç¨‹åº¦ã®åŠ å·¥ã§ã‚ã‚Œã°å‰å›ã®æ–¹æ³•ã®ã»ã†ãŒæ‰‹è»½ã§ã™ã­ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ axum ã® middleware ã® `tower::Service` and `Pin<Box<dyn Future>>` ã‚’è¦‹ã¾ã—ãŸã€‚

ä»Šå›ã‚‚ã¾ãŸ axum ã¨ã„ã†ã‚ˆã‚Šã¯ tower ã‚’è¦‹ã¦ã„ã‚‹å½¢ã§ã—ãŸã€‚

æ¬¡å›ã‚‚å¼•ãç¶šãã€ä»–ã® Middleware ã‚’æ›¸ãæ–¹æ³•ã‚‚è¦‹ã¦ã„ã“ã†ã¨æ€ã„ã¾ã™ã€‚
