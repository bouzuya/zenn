---
emoji: "ğŸ“–"
publication_name: "doctormate"
published: true
published_at: 2026-01-12 12:00
title: "axum crate ã® Handler ã®å®Ÿè£…ã‚’è¦‹ã¦ã¿ã‚ˆã†"
topics: ["rust"]
type: "tech"
---

[å‰å›ã¯ axum crate ã® Handler ã«ã¤ã„ã¦æ›¸ãã¾ã—ãŸ](https://zenn.dev/doctormate/articles/5657ef250f7bd2)ã€‚

ä»Šå›ã¯ [axum crate](https://crates.io/crates/axum) ã® Handler ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## é–¢æ•°ã®ãŸã‚ã® Handler ã®å®Ÿè£…

ã¾ãšã¯ã€ã‚‚ã£ã¨ã‚‚ã‚ã‚Šãµã‚ŒãŸå½¢ã§ã‚ã‚‹é–¢æ•°ã®ãŸã‚ã«æä¾›ã•ã‚Œã¦ã„ã‚‹ `Handler` trait ã®ãƒ–ãƒ©ãƒ³ã‚±ãƒƒãƒˆå®Ÿè£…ã‚’è¦‹ã¾ã™ã€‚

### å¼•æ•°ãŒãªã„é–¢æ•°ã®ãŸã‚ã®å®Ÿè£…

å¼•æ•°ãŒãªã„é–¢æ•°ã®ãŸã‚ã®å®Ÿè£…ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/handler/mod.rs#L193-L204>

```rust
impl<F, Fut, Res, S> Handler<((),), S> for F
where
    F: FnOnce() -> Fut + Clone + Send + Sync + 'static,
    Fut: Future<Output = Res> + Send,
    Res: IntoResponse,
{
    type Future = Pin<Box<dyn Future<Output = Response> + Send>>;

    fn call(self, _req: Request, _state: S) -> Self::Future {
        Box::pin(async move { self().await.into_response() })
    }
}
```

é–¢æ•°ã‚’å‘¼ã³å‡ºã— `into_response` ã—ãŸçµæœã‚’ `async {}` ã— `Box::pin` ã—ã¦è¿”ã—ã¦ã„ã¾ã™ã€‚ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œãªã©ã¯è¤‡æ•°å¼•æ•°ã®ã¨ãã®èª¬æ˜ã¨é‡è¤‡ã™ã‚‹ã®ã§å¾Œè¿°ã—ã¾ã™ã€‚

### è¤‡æ•°å¼•æ•°ã®é–¢æ•°ã®ãŸã‚ã®å®Ÿè£… impl_handler macro ã¨ãã®ä½¿ç”¨ç®‡æ‰€

è¤‡æ•°å¼•æ•°ã®é–¢æ•°ã®ãŸã‚ã®å®Ÿè£…ã§ã‚ã‚‹ `impl_handler` macro ã®å®šç¾©ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/handler/mod.rs#L206-L244>

```rust
macro_rules! impl_handler {
    (
        [$($ty:ident),*], $last:ident
    ) => {
        #[allow(non_snake_case, unused_mut)]
        impl<F, Fut, S, Res, M, $($ty,)* $last> Handler<(M, $($ty,)* $last,), S> for F
        where
            F: FnOnce($($ty,)* $last,) -> Fut + Clone + Send + Sync + 'static,
            Fut: Future<Output = Res> + Send,
            S: Send + Sync + 'static,
            Res: IntoResponse,
            $( $ty: FromRequestParts<S> + Send, )*
            $last: FromRequest<S, M> + Send,
        {
            type Future = Pin<Box<dyn Future<Output = Response> + Send>>;


            fn call(self, req: Request, state: S) -> Self::Future {
                let (mut parts, body) = req.into_parts();
                Box::pin(async move {
                    $(
                        let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
                    )*


                    let req = Request::from_parts(parts, body);


                    let $last = match $last::from_request(req, &state).await {
                        Ok(value) => value,
                        Err(rejection) => return rejection.into_response(),
                    };


                    self($($ty,)* $last,).await.into_response()
                })
            }
        }
    };
}
```

è©³ç´°ã¯å¾Œã«å›ã—ã¦ã€ `impl_handler` ã®ä½¿ç”¨ç®‡æ‰€ (å‘¼ã³å‡ºã—) ã‚’è¦‹ã¾ã™ã€‚ `all_the_tuples` macro ã«æ¸¡ã™å½¢ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚

`all_the_tuples!(impl_handler);`

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/handler/mod.rs#L246>

### all_the_tuples macro

`all_the_tuples` macro ã®å®šç¾©ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/macros.rs#L49-L68>

```rust
macro_rules! all_the_tuples {
    ($name:ident) => {
        $name!([], T1);
        $name!([T1], T2);
        $name!([T1, T2], T3);
        $name!([T1, T2, T3], T4);
        $name!([T1, T2, T3, T4], T5);
        $name!([T1, T2, T3, T4, T5], T6);
        $name!([T1, T2, T3, T4, T5, T6], T7);
        $name!([T1, T2, T3, T4, T5, T6, T7], T8);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8], T9);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9], T10);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], T11);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11], T12);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12], T13);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13], T14);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14], T15);
        $name!([T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15], T16);
    };
}
```

T1 ã€œ T16 ã®å¯å¤‰ã®å¼•æ•°ã«å¯¾ã—ã¦æ¸¡ã•ã‚ŒãŸ macro ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

### impl_handler macro ã®ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œ

`impl_handler` macro ã®å®šç¾©ã®è©³ç´°ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

ã¾ãš `Handler` ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œã‚’è¦‹ã¾ã™ã€‚

```rust
impl<F, Fut, S, Res, M, $($ty,)* $last> Handler<(M, $($ty,)* $last,), S> for F
where
    F: FnOnce($($ty,)* $last,) -> Fut + Clone + Send + Sync + 'static,
    Fut: Future<Output = Res> + Send,
    S: Send + Sync + 'static,
    Res: IntoResponse,
    $( $ty: FromRequestParts<S> + Send, )*
    $last: FromRequest<S, M> + Send,
```

`impl<...> Handler<...> for F` ã® `F` ã¯ `FnOnce($($ty,)* $last,) -> Fut + Clone + Send + Sync + 'static` ã§ã™ã€‚

`F` ã¯ `FnOnce` ã§ `Clone + Send + Sync + 'static` ã‚’æº€ãŸã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

`F` ã® `FnOnce` ã®å¼•æ•°ã¯ T1 ã‹ã‚‰ T16 ã®å¯å¤‰ã§ã™ã€‚ã“ã®ãŸã‚ã® `all_the_tuples!` ã§ã™ã­ã€‚æœ€å¾Œã®ã²ã¨ã¤ã¯ `$last` ã§ç‰¹åˆ¥æ‰±ã„ã•ã‚Œã¦ã„ã¾ã™ã€‚

æœ€å¾Œã®ã²ã¨ã¤ã®ã¿ `FromRequest<S, M> + Send` ã§ãã‚Œä»¥å¤–ã¯ `FromRequestParts<S> + Send` ã§ã™ã€‚

`S` ã¯ `Send + Sync + 'static` ã€‚ `M` ã¯ä»»æ„ã®å‹ã§ã™ã­ã€‚

`FromRequest` ã¨ `FromRequestParts` ã¯ Extractor ã¨ãªã‚‹ãŸã‚ã® trait ã§ã€ Extractor ã«ã¤ã„ã¦æ›¸ãéš›ã«æ”¹ã‚ã¦èª¿ã¹ã¾ã™ã€‚ã²ã¨ã¾ãš `S` ã¯ `State` ã®å‹ã§ã™ã€‚

<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequest.html>
<https://docs.rs/axum/0.8.4/axum/extract/trait.FromRequestParts.html>

`F` ã® `FnOnce` ã®æˆ»ã‚Šå€¤ã¯ `Fut` ã§ã™ã€‚ `Fut` ã¯ `Future<Output = Res> + Send` ã§ã™ã€‚

`Res` ã¯ `IntoResponse` ã§ã™ã€‚

ãƒ«ãƒ¼ãƒ«é€šã‚Šã®ã‚‚ã®ã¸ã®å®Ÿè£…ãŒæä¾›ã•ã‚Œã¦ã„ãã†ã§ã™ã€‚

### impl_handler macro ã®ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œ

`impl_handler` macro ã®å®šç¾©ã®è©³ç´°ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

æ¬¡ã« `Handler` ã®å®Ÿè£…ã‚’è¦‹ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/handler/mod.rs#L220-L241>

```rust
type Future = Pin<Box<dyn Future<Output = Response> + Send>>;

fn call(self, req: Request, state: S) -> Self::Future {
    let (mut parts, body) = req.into_parts();
    Box::pin(async move {
        $(
            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                Ok(value) => value,
                Err(rejection) => return rejection.into_response(),
            };
        )*

        let req = Request::from_parts(parts, body);

        let $last = match $last::from_request(req, &state).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response(),
        };

        self($($ty,)* $last,).await.into_response()
    })
}
```

æœ€å¾Œã®ã²ã¨ã¤ä»¥å¤–ã¯ `from_request_parts` ã‚’å‘¼ã³ã€æœ€å¾Œã®ã²ã¨ã¤ã¯ `from_request` ã‚’å‘¼ã³ã¾ã™ã€‚

æœ€å¾Œã¯ `self` ã‚’å‘¼ã³å‡ºã—ã¦ `into_response` ã€‚ç´ ç›´ãªå®Ÿè£…ã§ã™ã­ã€‚

å…¨ä½“ã‚’ `async {}` ã§æ‹¬ã£ã¦ `Box::pin` ã—ã¦è¿”ã—ã¦ã„ã¾ã™ã€‚

## IntoResponse ã®ãŸã‚ã® Handler ã®å®Ÿè£…

[å‰å›](https://zenn.dev/doctormate/articles/5657ef250f7bd2)é©šã„ãŸ `IntoResponse` ãªå€¤ã®ãŸã‚ã® `Handler` ã®ãƒ–ãƒ©ãƒ³ã‚±ãƒƒãƒˆå®Ÿè£…ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/handler/mod.rs#L248-L263>

```rust
mod private {
    // Marker type for `impl<T: IntoResponse> Handler for T`
    #[allow(missing_debug_implementations)]
    pub enum IntoResponseHandler {}
}

impl<T, S> Handler<private::IntoResponseHandler, S> for T
where
    T: IntoResponse + Clone + Send + Sync + 'static,
{
    type Future = std::future::Ready<Response>;

    fn call(self, _req: Request, _state: S) -> Self::Future {
        std::future::ready(self.into_response())
    }
}
```

ã™ã£ãã‚Šã—ãŸå®Ÿè£…ã§ã™ã€‚ `into_response` ã—ãŸã‚‚ã®ã‚’ `std::future::ready` ã§è¿”ã™ã ã‘ã§ã™ã­ã€‚

## ãŠã‚ã‚Šã«

axum crate ã® `Handler` ã®å®Ÿè£…ã‚’è¦‹ã¦ã¿ã¾ã—ãŸã€‚

æ¬¡å›ã¯ Extractor ã‚’è¿½ã„ã‹ã‘ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚
