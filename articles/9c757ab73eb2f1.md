---
emoji: "🐙"
publication_name: "doctormate"
published: true
published_at: 2026-03-23 12:00
title: "axum crate の Middleware (4) tower's combinators"
topics: ["rust"]
type: "tech"
---

[前回は axum の middleware のドキュメントの Writing middleware から axum::middleware::from_extractor について見ました](https://zenn.dev/doctormate/articles/2582963afb4646)。

今回は axum の middleware のドキュメントから tower's combinators 以降を読んでいきます。

今回も axum crate のバージョンは 0.8.4 です。

## tower's combinators

まずはドキュメントを見ます。前回は `axum::middleware::from_extractor` のところまでだったので、その続きの tower's combinators からです。

<https://docs.rs/axum/0.8.4/axum/middleware/index.html>

ドキュメントでは tower の combinator の例として次のものが挙げられています。

- [`ServiceBuilder::map_request`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.map_request)
- [`ServiceBuilder::map_response`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.map_response)
- [`ServiceBuilder::then`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.then)
- [`ServiceBuilder::and_then`](https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html#method.and_then)

これら `tower::ServiceBuilder` のメソッドです。 `ServiceBuilder` のドキュメントにあるとおり、ビルダーっぽい形で `tower::Service` を合成して構築するためのものです。

<https://docs.rs/tower/0.5.2/tower/builder/struct.ServiceBuilder.html>

axum の middleware のドキュメントでは、ヘッダーの追加のような、アドホックな小さい操作を加えるとき、かつ crate として公開しない場合に使うと良いと書いてあります。

ぼくの解釈としては、これらは axum の Middleware をつくるというよりは `tower::Service` をつくるためのものです。

axum は Middleware として `tower::Service` を使うと説明してきたとおり、両者はほとんど同じものではありますが、実際に axum の Middleware として適用するためには、最終的に `tower::Service` の関連型について、 `Error` を `Into<std::convert::Infallible>` にしたり、 `Request` を `axum::http::Request<axum::body::Body>` にしたり、 `Response` を `axum::response::IntoResponse` にするなどの対応が必要になります。乱暴に言うなら `tower::Service` のほうがより汎用です。

さて、各メソッドをもうすこし詳しく見ていきます。

## `tower::ServiceBuilder::map_request` の実装

```rust
pub fn map_request<F, R1, R2>(
    self,
    f: F,
) -> ServiceBuilder<Stack<crate::util::MapRequestLayer<F>, L>>
where
    F: FnMut(R1) -> R2 + Clone,
{
    self.layer(crate::util::MapRequestLayer::new(f))
}
```

`MapRequestLayer` を `ServiceBuilder::layer` として追加するようです。

<https://docs.rs/tower/0.5.2/tower/util/struct.MapRequestLayer.html>

```rust
impl<F> MapRequestLayer<F> {
    /// Creates a new [`MapRequestLayer`].
    pub const fn new(f: F) -> Self {
        MapRequestLayer { f }
    }
}

impl<S, F> Layer<S> for MapRequestLayer<F>
where
    F: Clone,
{
    type Service = MapRequest<S, F>;

    fn layer(&self, inner: S) -> Self::Service {
        MapRequest {
            f: self.f.clone(),
            inner,
        }
    }
}
```

`MapRequestLayer` は `MapRequest` を Service として返す Layer です。

```rust
impl<S, F, R1, R2> Service<R1> for MapRequest<S, F>
where
    S: Service<R2>,
    F: FnMut(R1) -> R2,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;

    #[inline]
    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), S::Error>> {
        self.inner.poll_ready(cx)
    }

    #[inline]
    fn call(&mut self, request: R1) -> S::Future {
        self.inner.call((self.f)(request))
    }
}
```

`MapRequest` はいかにも map ですね。

`map_response` や `then` や `and_then` もほとんど同じつくりになっていたので、以降は割愛します。

## `map_request` を試してみる

<https://github.com/bouzuya/rust-examples/blob/ae2f0dad56a203cab59084732f83e8218483acdd/axum10/src/main.rs>

```rust
#[tokio::test]
async fn test_map_request() -> anyhow::Result<()> {
    async fn handler(header_map: axum::http::HeaderMap) -> String {
        format!("X-NAME: {:?}", header_map.get("X-NAME"))
    }

    let app = axum::Router::<()>::new()
        .route("/", axum::routing::get(handler))
        .layer(tower::ServiceBuilder::new().map_request(
            |mut request: axum::http::Request<axum::body::Body>| {
                request
                    .headers_mut()
                    .insert("X-NAME", axum::http::HeaderValue::from_static("bouzuya"));
                request
            },
        ));
    let response = send_request(
        app,
        axum::http::Request::builder()
            .method("GET")
            .uri("/")
            .body(axum::body::Body::empty())?,
    )
    .await?;
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(
        response.into_body_string().await?,
        "X-NAME: Some(\"bouzuya\")"
    );
    Ok(())
}
```

`map_request` を使用してリクエストヘッダーを追加する Middleware を試しに書いてみました。ここでは `Request` を加工して返しているだけですね。

## `map_response` を試してみる

<https://github.com/bouzuya/rust-examples/blob/ae2f0dad56a203cab59084732f83e8218483acdd/axum10/src/main.rs>

```rust
#[tokio::test]
async fn test_map_response() -> anyhow::Result<()> {
    let app = axum::Router::<()>::new()
        .route("/", axum::routing::get("Original Body"))
        .layer(tower::ServiceBuilder::new().map_response(
            |mut response: axum::http::Response<axum::body::Body>| {
                *response.body_mut() = axum::body::Body::from("New Body");
                response
            },
        ));
    let response = send_request(
        app,
        axum::http::Request::builder()
            .method("GET")
            .uri("/")
            .body(axum::body::Body::empty())?,
    )
    .await?;
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(response.into_body_string().await?, "New Body");
    Ok(())
}
```

`map_response` を使用してリクエストボディを書き換える Middleware を試しに書いてみました。ここでも `Response` を加工して返しているだけですね。

## `then` を試してみる

<https://github.com/bouzuya/rust-examples/blob/ae2f0dad56a203cab59084732f83e8218483acdd/axum10/src/main.rs>

```rust
#[tokio::test]
async fn test_then() -> anyhow::Result<()> {
    let app = axum::Router::<()>::new()
        .route("/", axum::routing::get("Original Body"))
        .layer(tower::ServiceBuilder::new().then(
            |result: Result<
                axum::response::Response<axum::body::Body>,
                std::convert::Infallible,
            >| async {
                match result {
                    Ok(mut response) => {
                        *response.body_mut() = axum::body::Body::from("New Body");
                        Ok(response)
                    }
                    Err(e) => Err(e),
                }
            },
        ));
    let response = send_request(
        app,
        axum::http::Request::builder()
            .method("GET")
            .uri("/")
            .body(axum::body::Body::empty())?,
    )
    .await?;
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(response.into_body_string().await?, "New Body");
    Ok(())
}
```

`then` です。これは `Result` を受け取れるのですが、今回の例はイマイチですね。本来は成功のものを条件次第で失敗扱いにしたり、その逆ができると思うのですが、今回は単一の Middleware として書いているので、そういう活かし方はできませんでした。おそらく複数の Middleware を組み合わせる際に使えば、戻り値の調整に使えると思います。

## `and_then` を試してみる

<https://github.com/bouzuya/rust-examples/blob/ae2f0dad56a203cab59084732f83e8218483acdd/axum10/src/main.rs>

```rust
#[tokio::test]
async fn test_and_then() -> anyhow::Result<()> {
    let app = axum::Router::<()>::new()
        .route("/", axum::routing::get("Original Body"))
        .layer(tower::ServiceBuilder::new().and_then(
            |mut response: axum::response::Response<axum::body::Body>| async move {
                *response.body_mut() = axum::body::Body::from("New Body");
                Result::<
                            axum::response::Response<axum::body::Body>,
                            std::convert::Infallible,
                        >::Ok(response)
            },
        ));
    let response = send_request(
        app,
        axum::http::Request::builder()
            .method("GET")
            .uri("/")
            .body(axum::body::Body::empty())?,
    )
    .await?;
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(response.into_body_string().await?, "New Body");
    Ok(())
}
```

`and_then` です。これは `then` に似た動きを成功時の値をもとに……というところですね。感想については `then` 側とほとんど同じです。


## おわりに

今回は axum の middleware の tower's combinators を見ました。

axum というよりは tower を見ているに近い形でした。

次回も引き続き、他の Middleware を書く方法も見ていこうと思います。

