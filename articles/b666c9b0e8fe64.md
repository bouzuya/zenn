---
emoji: "ğŸ‚"
publication_name: "doctormate"
published: true
published_at: 2025-12-15 12:00
title: "axum crate ã® Router::fallback"
topics: ["rust"]
type: "tech"
---

# axum crate ã® Router::fallback

[å‰å›ã¯ axum crate ã® Router ãŒã©ã†å‹•ãã®ã‹ã‚’ã‚ã‚‹ç¨‹åº¦è¿½ã„ã‹ã‘ã¦ã¿ã¾ã—ãŸ](https://zenn.dev/doctormate/articles/1f4fc2ba5dc793) ã€‚

ä»Šå›ã¯ axum crate ã® Router::fallback ãƒ¡ã‚½ãƒƒãƒ‰ã®å‹•ãã‚’è¿½ã„ã‹ã‘ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

ä»Šå›ã‚‚ axum crate ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ 0.8.4 ã§ã™ã€‚

## å‰å›ã®ãŠã•ã‚‰ã„

å‰å›ã®å†…å®¹ã‹ã‚‰ä¸€éƒ¨ãŠã•ã‚‰ã„ã—ã¾ã™ã€‚å‰å›ã®è¨˜äº‹ã§ç¢ºèªã—ãŸ `Router::call_with_state` ã‚’æ”¹ã‚ã¦ç¢ºèªã—ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/mod.rs#L416-L431>

```rust
pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<Infallible> {
    let (req, state) = match self.inner.path_router.call_with_state(req, state) {
        Ok(future) => return future,
        Err((req, state)) => (req, state),
    };


    let (req, state) = match self.inner.fallback_router.call_with_state(req, state) {
        Ok(future) => return future,
        Err((req, state)) => (req, state),
    };


    self.inner
        .catch_all_fallback
        .clone()
        .call_with_state(req, state)
}
```

`path_router` â†’ `fallback_router` â†’ `catch_all_fallback` ã¨é †ã« `call_with_state` ã‚’è©¦ã—ã¾ã™ã€‚

`PathRouter::call_with_state` ã¯ãƒãƒƒãƒã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒãªã‘ã‚Œã°å¤±æ•—ã—ã¾ã™ã€‚

ã¤ã¾ã‚Š `path_router` ã§ãƒãƒƒãƒã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒãªã‘ã‚Œã° `fallback_router` ã«æ¥ã‚‹ã€ã¨ã„ã†ã‚ã‘ã§ã™ã€‚

ã“ã‚Œã‚’è¸ã¾ãˆã¦ `fallback` ã‚’è¦‹ã¦ã„ãã¾ã™ã€‚

## Router::fallback

[`Router::fallback`](https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.fallback) ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¯æ¬¡ã®ã‚ˆã†ã«ã‚ã‚Šã¾ã™ã€‚

- fallback handler ã‚’ãƒ«ãƒ¼ã‚¿ãƒ¼ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
- ãƒ«ãƒ¼ãƒˆã«ãƒãƒƒãƒã—ãªã‹ã£ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹
- ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒ 404 ã‚’è¿”ã—ã¦ã‚‚å‘¼ã³å‡ºã•ã‚Œãªã„

ç¢ºèªã—ã¦ããŸå®Ÿè£…ã®èª¬æ˜ãŒç°¡æ½”ã«æ›¸ã„ã¦ã‚ã‚Šã¾ã™ã€‚ 3 ç‚¹ç›®ã®æ³¨æ„äº‹é …ã‚‚å¤§åˆ‡ã§ã™ã€‚ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒ HTTP 404 (NotFound) ãªã©ã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¦ã‚‚ fallback handler ã¯å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚

## Router::method_not_allowed_fallback

ã‚³ãƒ¼ãƒ‰ä¾‹ã®å‰ã«ã‚‚ã†ã²ã¨ã¤ãƒ¡ã‚½ãƒƒãƒ‰ã«è§¦ã‚ŒãŸã„ã§ã™ã€‚

[`Router::method_not_allowed_fallback`](https://docs.rs/axum/0.8.4/axum/struct.Router.html#method.method_not_allowed_fallback) ã§ã™ã€‚

`Router::fallback` ã¯ãƒ‘ã‚¹ã«ãƒãƒƒãƒã—ãªã‹ã£ãŸã¨ãã§ã™ãŒã€ãƒ‘ã‚¹ã«ãƒãƒƒãƒã‹ã¤ãƒ¡ã‚½ãƒƒãƒ‰ã«ãƒãƒƒãƒã—ãªã‹ã£ãŸã¨ãã«ã¯ä½¿ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚

æ—¢å®šã§ã¯ 405 Method Not Allowed ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã“ã“ã‚’å¤‰æ›´ã™ã‚‹å ´åˆã¯ `Router::method_not_allowed_fallback` ã«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’æŒ‡å®šã§ãã¾ã™ã€‚

æ³¨æ„äº‹é …ã¨ã—ã¦ã¯ã€ãƒ‘ã‚¹ã«ãƒãƒƒãƒã›ãšã€ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚‚ãƒãƒƒãƒã—ãªã‹ã£ãŸã¨ãã¯ `Router::fallback` ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒä½¿ç”¨ã•ã‚Œã‚‹ç‚¹ã§ã™ã€‚ã‚„ã‚„ã“ã—ã„ã§ã™ã­â€¦â€¦ã€‚

å®Ÿè£…ã¨ã—ã¦ã¯å‰å›è¦‹ãŸã¨ãŠã‚Š `PathRouter` â†’ `MethodRouter` ã§å‡¦ç†ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã­ã€‚

`Router::method_not_allowed_fallback` ã®å®Ÿè£…ã‚’è¦‹ã¦ã‚‚ã€ `self.inner.fallback_router` ã§ã¯ãªã `self.inner.path_router` ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã­ã€‚

<https://docs.rs/axum/0.8.4/src/axum/routing/mod.rs.html#373-382>

```rust
pub fn method_not_allowed_fallback<H, T>(self, handler: H) -> Self
where
    H: Handler<T, S>,
    T: 'static,
{
    tap_inner!(self, mut this => {
        this.path_router
            .method_not_allowed_fallback(handler.clone());
    })
}
```

ã•ã‚‰ã« `PathRouter::method_not_allowed_fallback` ã§ã¯ `MethodRouter` ã« `default_fallback` ã§è¨­å®šã—ã¦ã„ã¾ã™ã€‚

<https://github.com/tokio-rs/axum/blob/axum-v0.8.4/axum/src/routing/path_router.rs#L116-L126>

```rust
pub(super) fn method_not_allowed_fallback<H, T>(&mut self, handler: H)
where
    H: Handler<T, S>,
    T: 'static,
{
    for (_, endpoint) in self.routes.iter_mut() {
        if let Endpoint::MethodRouter(rt) = endpoint {
            *rt = rt.clone().default_fallback(handler.clone());
        }
    }
}
```

## ã‚³ãƒ¼ãƒ‰ä¾‹

ã•ã¦ã€é å›ã‚Šã—ãŸã®ã§ã™ãŒã€ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã™ã€‚è©¦ã—ã« 404 ã¨ 405 ã‚’ 200 ã«ã—ã¦ body ã« fallback ã ã¨åˆ†ã‹ã‚‹æ–‡å­—åˆ—ã‚’å«ã‚ã¾ã™ã€‚

<https://github.com/bouzuya/rust-examples/blob/cbf90f555d773ef11d1ed1437b338674ef13ebf4/axum5/src/main.rs>

```rust
async fn fallback_handler() -> impl axum::response::IntoResponse {
    (axum::http::StatusCode::OK, "fallback")
}

async fn method_not_allowed_fallback() -> impl axum::response::IntoResponse {
    (axum::http::StatusCode::OK, "method_not_allowed_fallback")
}

fn router() -> axum::Router<()> {
    axum::Router::new()
        .route("/", axum::routing::get(root))
        .route("/users", axum::routing::post(create_user))
        .route("/users/{user_id}", axum::routing::get(get_user))
        .fallback(fallback_handler)
        .method_not_allowed_fallback(method_not_allowed_fallback)
}
```

```rust
// ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
#[tokio::test]
async fn test_path_not_found() -> anyhow::Result<()> {
    let router = router();
    let request = axum::http::Request::builder()
        .method(axum::http::Method::GET)
        .uri("/unknown")
        .body(axum::body::Body::empty())?;
    let response = send_request(router, request).await?;
    // no fallback => HTTP 404
    // assert_eq!(response.status(), axum::http::StatusCode::NOT_FOUND);
    // assert_eq!(response.into_body_string().await?, "");
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(response.into_body_string().await?, "fallback");
    Ok(())
}

#[tokio::test]
async fn test_method_not_allowed() -> anyhow::Result<()> {
    let router = router();
    let request = axum::http::Request::builder()
        .method(axum::http::Method::POST)
        .uri("/")
        .body(axum::body::Body::empty())?;
    let response = send_request(router, request).await?;
    // no fallback => HTTP 405
    // assert_eq!(
    //     response.status(),
    //     axum::http::StatusCode::METHOD_NOT_ALLOWED
    // );
    // assert_eq!(response.into_body_string().await?, "");
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(
        response.into_body_string().await?,
        "method_not_allowed_fallback"
    );
    Ok(())
}

#[tokio::test]
async fn test_other_default_fallback() -> anyhow::Result<()> {
    let router = router();
    let request = axum::http::Request::builder()
        .method(axum::http::Method::POST)
        .uri("/unknown")
        .body(axum::body::Body::empty())?;
    let response = send_request(router, request).await?;
    // no fallback => HTTP 404
    // assert_eq!(response.status(), axum::http::StatusCode::NOT_FOUND);
    // assert_eq!(response.into_body_string().await?, "");
    assert_eq!(response.status(), axum::http::StatusCode::OK);
    assert_eq!(response.into_body_string().await?, "fallback");
    Ok(())
}
```

ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯æ¬¡å›è©³ç´°ã«è§¦ã‚Œã¾ã™ãŒã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã©ãŠã‚Šãƒ»æœŸå¾…ã©ãŠã‚Šã®å‹•ãã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

## ãŠã‚ã‚Šã«

ä»Šå›ã¯ axum crate ã® `Router::fallback` (ã¨ `Router::method_not_allowed_fallback`) ã«ã¤ã„ã¦æ›¸ãã¾ã—ãŸã€‚ fallback ã¾ã‚ã‚Šã®å‹•ä½œã«ã¤ã„ã¦ã¯ `merge` ã‚„ `nest` ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å†åº¦è§¦ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

æ¬¡å›ã¯ axum crate ã®ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦æ›¸ããŸã„ã¨æ€ã„ã¾ã™ã€‚
