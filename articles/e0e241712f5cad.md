---
emoji: "😊"
publication_name: "doctormate"
published: true
published_at: 2026-04-13 12:00
title: "impl From での構造体の詰め替え時に destructuring するパターン"
topics: ["rust"]
type: "tech"
---

## TL;DR

構造体の詰め替え時 (`impl From`) は引数位置で destructuring すると取り違えに気づけたりフィールド追加時にコンパイルエラーが出ていいぞ。

## 業務 Rust で発生する構造体の詰め替え

業務で Rust を書いていると、レイヤードアーキテクチャの採用したり、レイヤーごとに構造体を用意したり、それらを変換・詰め替えたりすることがあると思います。

たとえば次のような形です。

```rust
// HTTP サーバーからのレスポンス用の構造体
pub struct CreateUserResponseBody {
    pub email: String,
    pub id: String,
    pub name: String,
}

// 変換処理
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(output: CreateUserOutput) -> Self {
        Self {
            email: output.email,
            id: output.id,
            name: output.name,
        }
    }
}

// ↓は別レイヤー

// 内部的なユースケースの呼び出し結果用の構造体
pub struct CreateUserOutput {
    pub email: String,
    pub id: String,
    pub name: String,
}
```

フィールドがまったく同じというのは極端な例かもしれませんが、アーキテクチャ的な一貫性をつくるための制約として、類似の構造体をつくることになったり、単純な変換になるケースもままあると思います。

## 提案したいパターン

今回の記事で注目したいのは `impl From` の箇所です。

再掲すると、ここです。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(output: CreateUserOutput) -> Self {
        Self {
            email: output.email,
            id: output.id,
            name: output.name,
        }
    }
}
```

コードレビューでは「うんうん、詰め替えてるねー」で流してしまいそうな箇所です。

ここを次のように書き換えたほうが良いのではないか、というのが今回の提案です。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(CreateUserOutput { email, id, name }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

最終的な挙動は変わりません。

では、どういうメリットがあるのでしょうか。

## このパターンを適用するメリット

### 取り違えるミスを防ぐ

まずは同じ型の場合の取り違えるミスを防げることです。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(output: CreateUserOutput) -> Self {
        Self {
            email: output.email,
            id: output.email, // 取り違えている
            name: output.name,
        }
    }
}
```

これは詰め替えのミスがあるコードです。 `id` に `email` を取り違える形でミスして詰めています。

こんな間違いはしないと思うかもしれませんが、コピペして行を増やし、詰め替え先のフィールド名だけを書き換えて、元のフィールド名を書き換えそびれて……といった形で意外と発生します。こういう間違いは、ほとんど発生しないからこそ怖いです。

コードレビュー時に気づけばいいのですが、読み飛ばしてしまうものです。

改めて提案しているパターン (改善案) を見てみます。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(CreateUserOutput { email, id, name }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

今回の例は同一フィールド名なので、特に間違える余地が少ないです。フィールド名が違うケースでも、大部分が同じというケースもあるので、採用しておくほうが安全です。

### フィールドの増加時にコンパイルエラーになる

`CreateUserOutput` に `birth_date` フィールドが追加される状況を考えてみましょう。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(output: CreateUserOutput) -> Self {
        Self {
            email: output.email,
            id: output.id,
            name: output.name,
            // 本来は birth_date を追加すべき
        }
    }
}
```

元のコードではコンパイルエラーにはなりません。

提案しているパターン (改善案) を見てみます。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    // ここで birth_date がないためコンパイルエラー
    fn from(CreateUserOutput { email, id, name }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

改善案ではコンパイルエラーになります。コンパイルエラーが発生することで `CreateUserResponseBody` 側にも追加する必要がある可能性に気づけます。

細かいことですが、このパターンでは `..` による省略なども避けておく必要があります。そうしないとコンパイルエラーが発生しません。

ここで、ありそうな意見として「レイヤーが違うのは別物で切り離したいからこそこうしていてコンパイルエラーにならないのは妥当」というものがあります。それはある意味で正しいと思います。

ただ、あえてコンパイルエラーとして出る、明示的に無視するコードを要求されるほうが気づくタイミングが生まれるという意味で良いと考えています。

```rust
impl From<CreateUserOutput> for CreateUserResponseBody {
    fn from(CreateUserOutput {
        // birth_date はレスポンスには含めない (無視することを明示)
        birth_date: _,
        email,
        id,
        name
    }: CreateUserOutput) -> Self {
        Self {
            email,
            id,
            name,
        }
    }
}
```

# おわりに

細かい Tips ですが、 Rust で防御的なコードを書くためのパターンをひとつ紹介してみました。

そも、そんな変換が必要にならないようにすべき、 macro でなんとかすべき、などいろいろ意見・方針はあると思います。

あくまでも、ひとつのパターンとして、役に立つかもと思って書いてみました。
